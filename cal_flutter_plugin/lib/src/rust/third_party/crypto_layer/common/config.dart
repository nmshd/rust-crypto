// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../lib.dart';
import '../common.dart';
import 'crypto/algorithms/encryption.dart';
import 'crypto/algorithms/hashes.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'config.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `AdditionalConfigDiscriminants`, `SecurityLevelIter`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `cmp`, `discriminant`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from_str`, `from_str`, `from`, `from`, `from`, `from`, `from`, `from`, `iter`, `len`, `next_back`, `next`, `nth`, `partial_cmp`, `size_hint`, `try_from`, `try_from`, `zeroize`

@freezed
sealed class AdditionalConfig with _$AdditionalConfig {
  const AdditionalConfig._();

  /// Callback functions acting like a hashmap for storing key metadata.
  ///
  /// Mutually exclusive with [AdditionalConfig::FileStoreConfig].
  const factory AdditionalConfig.kvStoreConfig({
    required ArcFnStringDynFutureOptionVecU8 getFn,
    required ArcFnStringVecU8DynFutureBool storeFn,
    required ArcFnStringPinBoxFutureOutput deleteFn,
    required ArcFnDynFutureVecString allKeysFn,
  }) = AdditionalConfig_KVStoreConfig;

  /// Configuration for the usage of the metadata file database.
  ///
  /// Mutually exclusive with [AdditionalConfig::KVStoreConfig].
  const factory AdditionalConfig.fileStoreConfig({
    /// Path to a directory where the database holding key metadata will be saved.
    required String dbDir,
  }) = AdditionalConfig_FileStoreConfig;

  /// Enables integrity verification of key metadata.
  ///
  /// Mutually exclusive with [AdditionalConfig::StorageConfigDSA].
  const factory AdditionalConfig.storageConfigHmac(KeyHandle field0) =
      AdditionalConfig_StorageConfigHMAC;

  /// Enables integrity verification of key metadata.
  ///
  /// Mutually exclusive with [AdditionalConfig::StorageConfigHMAC].
  const factory AdditionalConfig.storageConfigDsa(KeyPairHandle field0) =
      AdditionalConfig_StorageConfigDSA;

  /// Enables encryption of sensitive key metadata.
  ///
  /// In case of the software provider, this enables encryption of secret keys.
  ///
  /// Mutually exclusive with [AdditionalConfig::StorageConfigAsymmetricEncryption].
  const factory AdditionalConfig.storageConfigSymmetricEncryption(
    KeyHandle field0,
  ) = AdditionalConfig_StorageConfigSymmetricEncryption;

  /// Enables encryption of sensitive key metadata.
  ///
  /// In case of the software provider, this enables encryption of secret keys.
  ///
  /// Mutually exclusive with [AdditionalConfig::StorageConfigSymmetricEncryption].
  const factory AdditionalConfig.storageConfigAsymmetricEncryption(
    KeyPairHandle field0,
  ) = AdditionalConfig_StorageConfigAsymmetricEncryption;
}

/// Struct used to configure key pairs.
///
/// It is important to note, that the configuration of a key can only happen at the point of its creation.
/// A key cannot be reconfigured.
/// flutter_rust_bridge:non_opaque
class KeyPairSpec {
  /// Asymmetric algorithm to be used.
  final AsymmetricKeySpec asymSpec;

  /// Cipher used for hybrid encryption. If set to None, no hybrid encryption will be used.
  final Cipher? cipher;

  /// Hash function used for signing and encrypting.
  final CryptoHash signingHash;

  /// If set to true, the key pair will be discarded after the handle is dropped.
  final bool ephemeral;

  /// If set to true, the key can't be exported (also software keys)
  final bool nonExportable;

  const KeyPairSpec({
    required this.asymSpec,
    this.cipher,
    required this.signingHash,
    required this.ephemeral,
    required this.nonExportable,
  });

  static Future<KeyPairSpec> default_() =>
      RustLib.instance.api.cryptoLayerCommonConfigKeyPairSpecDefault();

  @override
  int get hashCode =>
      asymSpec.hashCode ^
      cipher.hashCode ^
      signingHash.hashCode ^
      ephemeral.hashCode ^
      nonExportable.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyPairSpec &&
          runtimeType == other.runtimeType &&
          asymSpec == other.asymSpec &&
          cipher == other.cipher &&
          signingHash == other.signingHash &&
          ephemeral == other.ephemeral &&
          nonExportable == other.nonExportable;
}

/// Struct used to configure keys.
///
/// It is important to note, that the configuration of a key can only happen at the point of its creation.
/// A key cannot be reconfigured.
/// flutter_rust_bridge:non_opaque
class KeySpec {
  /// Cipher used for symmetric encryption.
  final Cipher cipher;

  /// Hash function used with HMAC.
  final CryptoHash signingHash;

  /// If set to `true`, metadata of the key is not stored and the key is going to be deleted when the handle is dropped.
  final bool ephemeral;

  /// If set to `true`, the key cannot be exported.
  ///
  /// Some providers do not allow exporting keys at all, even if set to `false`.
  final bool nonExportable;

  const KeySpec({
    required this.cipher,
    required this.signingHash,
    required this.ephemeral,
    required this.nonExportable,
  });

  static Future<KeySpec> default_() =>
      RustLib.instance.api.cryptoLayerCommonConfigKeySpecDefault();

  @override
  int get hashCode =>
      cipher.hashCode ^
      signingHash.hashCode ^
      ephemeral.hashCode ^
      nonExportable.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeySpec &&
          runtimeType == other.runtimeType &&
          cipher == other.cipher &&
          signingHash == other.signingHash &&
          ephemeral == other.ephemeral &&
          nonExportable == other.nonExportable;
}

/// Capabilities of a Provider
///
/// This configuration struct has multiple uses:
/// * Act as capabilities of a provider.
/// * Act as requirement for [`create_provider`](crate::prelude::create_provider).
///
/// Depending on the use some properties have different meanings:
/// * Currently a provider may only have one security level.
/// * The requester may ask for a provider that has at a minimum one security level or at a maximum another security level.
/// * A provider has certain algorithm he at least in some form supports.
/// * A requester may ask for minimum requirements regarding these algorithms.
///
/// ### Example
///
/// A provider might return capabilities like:
/// ```
/// # use crypto_layer::prelude::*;
/// # use std::collections::HashSet;
///
/// let apple_provider_capabilities = ProviderConfig {
///     max_security_level: SecurityLevel::Hardware,
///     min_security_level: SecurityLevel::Hardware,
///     supported_ciphers: HashSet::from([Cipher::AesGcm128, Cipher::AesGcm256]),
///     supported_asym_spec: HashSet::from([AsymmetricKeySpec::P256]),
///     supported_hashes: HashSet::from([
///         CryptoHash::Sha2_224,
///         CryptoHash::Sha2_256,
///         CryptoHash::Sha2_384,
///         CryptoHash::Sha2_512,
///     ]),
/// };
///
/// ```
/// Such provider then is ought to use a secure element (apart from the `ANDROID_PROVIDER`)
/// and at least support these algorithms **in one form or another** .
///
/// Please be aware, that `supported_ciphers` does not imply support for symmetric cryptography!
///
/// A requestor might ask for a provider with capabilities like:
/// ```
/// # use crypto_layer::prelude::*;
/// # use std::collections::HashSet;
///
/// let requested_capabilities = ProviderConfig {
///     max_security_level: SecurityLevel::Hardware,
///     min_security_level: SecurityLevel::Software,
///     supported_ciphers: HashSet::from([Cipher::AesGcm256]),
///     supported_asym_spec: HashSet::from([AsymmetricKeySpec::P256]),
///     supported_hashes: HashSet::from([
///         CryptoHash::Sha2_256,
///         CryptoHash::Sha2_512,
///     ]),
/// };
/// ```
///
/// As the requested capabilities are a subset of the provided capabilities above,
/// this requestor might be assigned the apple secure enclave provider on apple platforms.
///
/// flutter_rust_bridge:non_opaque
class ProviderConfig {
  /// Highest security supported or maximum security requested.
  ///
  /// As an example, the software fallback provider has a maximum security level of [`SecurityLevel::Software`].
  final SecurityLevel maxSecurityLevel;

  /// Minimum security level supported or security level required.
  ///
  /// As an example:
  /// If one wishes to use provider that is based on a secure element, one would require [`SecurityLevel::Hardware`].
  final SecurityLevel minSecurityLevel;

  /// Cipher algorithms supported in one fashion or another or cipher algorithms required.
  ///
  /// A provider might support cipher algorithms returned as capabilities in following ways:
  /// * Supports symmetric encryption with said cipher.
  /// * Supports asymmetric hybrid encryption with said cipher. (What standard is used for the hybrid encryption is not set.)
  final Set<Cipher> supportedCiphers;

  /// Hashing algorithm supported for either the use with signing (symmetric or asymmetric) operations or encryption operations (symmetric or asymmetric),
  /// or hashing algorithm required for the same purpose.
  ///
  /// A provider that supports a hash algorithm **may or may not** support following operations in combination with said hashing algorithm:
  /// * [`KeyHandle::hmac()`](crate::prelude::KeyHandle::hmac)
  /// * [`KeyHandle::verify_hmac()`](crate::prelude::KeyHandle::verify_hmac)
  /// * [`KeyHandle::encrypt()`](crate::prelude::KeyHandle::encrypt())
  /// * [`KeyHandle::decrypt_data()`](crate::prelude::KeyHandle::decrypt_data())
  /// * [`KeyPairHandle::sign_data`](crate::prelude::KeyPairHandle::sign_data)
  /// * [`KeyPairHandle::verify_signature`](crate::prelude::KeyPairHandle::verify_signature)
  /// * [`KeyPairHandle::encrypt_data()`](crate::prelude::KeyPairHandle::encrypt_data)
  /// * [`KeyPairHandle::decrypt_data()`](crate::prelude::KeyPairHandle::decrypt_data)
  final Set<CryptoHash> supportedHashes;

  /// Asymmetric cryptographic algorithms supported or required.
  ///
  /// A provider supporting an asymmetric cryptographic algorithm **may or may not** support said algorithm for signing or encryption operations.
  final Set<AsymmetricKeySpec> supportedAsymSpec;

  const ProviderConfig({
    required this.maxSecurityLevel,
    required this.minSecurityLevel,
    required this.supportedCiphers,
    required this.supportedHashes,
    required this.supportedAsymSpec,
  });

  @override
  int get hashCode =>
      maxSecurityLevel.hashCode ^
      minSecurityLevel.hashCode ^
      supportedCiphers.hashCode ^
      supportedHashes.hashCode ^
      supportedAsymSpec.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProviderConfig &&
          runtimeType == other.runtimeType &&
          maxSecurityLevel == other.maxSecurityLevel &&
          minSecurityLevel == other.minSecurityLevel &&
          supportedCiphers == other.supportedCiphers &&
          supportedHashes == other.supportedHashes &&
          supportedAsymSpec == other.supportedAsymSpec;
}

/// Key metadata store configuration
///
/// Due to an accident, this configuration became a vector.
///
/// If neither [`AdditionalConfig::KVStoreConfig`] nor [`AdditionalConfig::FileStoreConfig`] are supplied
/// to [`create_provider()`] or to [`create_provider_from_name()`],
/// a provider will be created that is only capable of creating ephemeral keys!
///
/// To protect key metadata against unauthorized change, it is recommended to make use of
/// [`AdditionalConfig::StorageConfigHMAC`] or [`AdditionalConfig::StorageConfigDSA`].
/// (This may only apply if you use multiple providers and one is of [`SecurityLevel::Hardware`] or above.)
///
/// If the fallback software provider is used with [AdditionalConfig::StorageConfigSymmetricEncryption]
/// or [AdditionalConfig::StorageConfigAsymmetricEncryption], the stored secret keys are secured by
/// the provided key, which in turn makes such construct a hybrid provider (as the keys at rest have hardware security protection).
///
///
/// ## Example
///
/// ```rust
/// # use crypto_layer::prelude::*;
///
/// let implementation_config = ProviderImplConfig {
///       additional_config: vec![
///          AdditionalConfig::FileStoreConfig {
///              db_dir: "./testdb".to_owned(),
///          }
///      ],
/// };
/// ```
///
/// [`create_provider()`]: crate::prelude::create_provider
/// [`create_provider_from_name()`]: crate::prelude::create_provider_from_name
///
/// flutter_rust_bridge:non_opaque
class ProviderImplConfig {
  final List<AdditionalConfig> additionalConfig;

  const ProviderImplConfig({required this.additionalConfig});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new `ProviderImplConfig` instance.
  static Future<ProviderImplConfig> newInstance({
    required ArcFnStringDynFutureOptionVecU8 getFn,
    required ArcFnStringVecU8DynFutureBool storeFn,
    required ArcFnStringPinBoxFutureOutput deleteFn,
    required ArcFnDynFutureVecString allKeysFn,
    required List<AdditionalConfig> additionalConfig,
  }) => RustLib.instance.api.cryptoLayerCommonConfigProviderImplConfigNew(
    getFn: getFn,
    storeFn: storeFn,
    deleteFn: deleteFn,
    allKeysFn: allKeysFn,
    additionalConfig: additionalConfig,
  );

  @override
  int get hashCode => additionalConfig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProviderImplConfig &&
          runtimeType == other.runtimeType &&
          additionalConfig == other.additionalConfig;
}

/// Enum describing the security level of a provider.
///
/// * [SecurityLevel::Hardware]: Provider is hardware backed (tpm, other security chips, StrongBox KeyStore).
/// * [SecurityLevel::Software]: Provider uses the systems software keystore.
/// * [SecurityLevel::Network]: Provider uses a network key store (HashiCorp).
/// * [SecurityLevel::Unsafe]: Provider uses software fallback.
enum SecurityLevel {
  /// Highest security level.
  ///
  /// Implies running on a TPM, HSM or TEE.
  /// The extraction of private keys is impossible.
  hardware,

  /// Keys are stored in an encrypted database or on a native software key store.
  ///
  /// Extraction of private keys is possible.
  software,

  /// NKS
  ///
  /// Extraction of private keys is possible.
  network,

  /// Lowest security level.
  ///
  /// Keys are stored in an unencrypted, insecure database or file.
  unsafe,
}

@freezed
sealed class Spec with _$Spec {
  const Spec._();

  const factory Spec.keySpec(KeySpec field0) = Spec_KeySpec;
  const factory Spec.keyPairSpec(KeyPairSpec field0) = Spec_KeyPairSpec;
}
