// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.5.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'hashes.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`

@freezed
sealed class CryptoHash with _$CryptoHash {
  const CryptoHash._();

  /// SHA-1 hashing algorithm.
  ///
  /// Considered insecure for most cryptographic purposes now due to vulnerabilities
  /// that allow for practical collision attacks.
  const factory CryptoHash.sha1() = CryptoHash_Sha1;

  /// SHA-2 family of hashing algorithms with selectable digest sizes.
  const factory CryptoHash.sha2(
    Sha2Bits field0,
  ) = CryptoHash_Sha2;

  /// SHA-3 family of hashing algorithms, also known as Keccak, with selectable digest sizes.
  const factory CryptoHash.sha3(
    Sha3Bits field0,
  ) = CryptoHash_Sha3;

  /// MD2 hashing algorithm.
  ///
  /// Considered cryptographically broken and unsuitable for further use due to significant
  /// vulnerabilities.
  const factory CryptoHash.md2() = CryptoHash_Md2;

  /// MD4 hashing algorithm.
  ///
  /// Faster but less secure than MD5; considered broken due to vulnerabilities to collision attacks.
  const factory CryptoHash.md4() = CryptoHash_Md4;

  /// MD5 hashing algorithm.
  ///
  /// Widely used historically but can no longer be considered secure against collision attacks,
  /// despite its continued use in non-cryptographic contexts like checksums.
  const factory CryptoHash.md5() = CryptoHash_Md5;

  /// RIPEMD-160 hashing algorithm.
  ///
  /// Designed to be a secure alternative to MD4 and MD5. It offers a good balance
  /// of security for applications requiring a hash function more resilient to the
  /// vulnerabilities affecting earlier Message Digest algorithms.
  const factory CryptoHash.ripemd160() = CryptoHash_Ripemd160;

  static Future<CryptoHash> default_() => RustLib.instance.api
      .cryptoLayerCommonCryptoAlgorithmsHashesCryptoHashDefault();
}

/// Specifies the digest sizes for the SHA-2 family of hashing algorithms.
///
/// This enum lists the supported digest sizes for SHA-2, providing a range of options
/// for different security and performance needs. The larger the digest size, the higher
/// the security level and collision resistance, but with a potential decrease in performance.
/// Selecting the appropriate digest size depends on the specific requirements of the application,
/// balancing security against computational overhead.
///
/// # Examples
///
/// Selecting a SHA-2 digest size:
///
/// ```rust
/// use crypto_layer::common::crypto::algorithms::hashes::Sha2Bits;
///
/// fn main() {
///     let digest_size = Sha2Bits::Sha512;
/// }
/// ```
///
/// # Note
///
/// `#[repr(C)]` attribute is used for C compatibility, facilitating interoperability with C-based systems.
/// flutter_rust_bridge:non_opaque
enum Sha2Bits {
  /// 224-bit digest size.
  sha224,

  /// 256-bit digest size, commonly used for its balance of security and performance.
  sha256,

  /// 384-bit digest size.
  sha384,

  /// 512-bit digest size, offering high security for sensitive applications.
  sha512,

  /// 224-bit digest size variant of SHA-512, designed for compatibility with SHA-224.
  sha512224,

  /// 256-bit digest size variant of SHA-512, optimized for security and efficiency.
  sha512256,
  ;
}

/// Specifies the digest sizes for the SHA-3 family of hashing algorithms.
///
/// SHA-3, also known as Keccak, offers a range of digest sizes to accommodate various
/// security levels and performance requirements. As a newer standard compared to SHA-2,
/// SHA-3 introduces a different cryptographic design that is resilient against many of the
/// vulnerabilities that affect older hashing algorithms. Choosing the correct digest size
/// allows developers to optimize for security and efficiency based on their specific needs.
/// A larger digest size generally provides higher security and collision resistance but may
/// come with a performance trade-off.
///
/// # Examples
///
/// Selecting a SHA-3 digest size:
///
/// ```rust
/// use crypto_layer::common::crypto::algorithms::hashes::Sha3Bits;
///
/// fn main() {
///     let digest_size = Sha3Bits::Sha3_384;
/// }
/// ```
///
/// # Note
///
/// Uses `#[repr(C)]` for C language compatibility, important for interoperability with C-based systems.
/// flutter_rust_bridge:non_opaque
enum Sha3Bits {
  /// 224-bit digest size for SHA-3.
  sha3224,

  /// 256-bit digest size for SHA-3
  sha3256,

  /// 384-bit digest size for SHA-3
  sha3384,

  /// 512-bit digest size for SHA-3
  sha3512,
  ;
}
