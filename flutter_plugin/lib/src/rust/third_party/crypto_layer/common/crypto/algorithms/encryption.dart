// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.5.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are not used by any `pub` functions: `ChCha20Mode`, `EccSigningScheme`, `Rc2KeyBits`, `TripleDesNumKeys`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AsymmetricKeySpec>>
abstract class AsymmetricKeySpec implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cipher>>
abstract class Cipher implements RustOpaqueInterface {
  static Future<Cipher> default_() => RustLib.instance.api
      .cryptoLayerCommonCryptoAlgorithmsEncryptionCipherDefault();
}

/// Specifies the curve types for Elliptic Curve Digital Signature Algorithm (ECDSA).
///
/// Lists the supported elliptic curve specifications for ECDSA, affecting security and performance.
/// Includes both NIST P-curves and others like secp256k1 and Brainpool curves.
///
/// # Examples
///
/// Selecting an ECDSA curve:
///
/// ```
/// use crypto_layer::common::crypto::algorithms::encryption::EccCurve;
///
/// fn main() {
///     let curve_type = EccCurve::P256;
/// }
/// ```
///
/// # Note
///
/// Uses `#[repr(C)]` for C language compatibility.
enum EccCurve {
  /// NIST P-256 curve.
  p256,

  /// NIST P-384 curve.
  p384,

  /// NIST P-521 curve.
  p521,

  /// secp256k1 curve, commonly used in blockchain technologies.
  secp256K1,

  /// Brainpool P256r1 curve.
  brainpoolP256R1,

  /// Brainpool P384r1 curve.
  brainpoolP384R1,

  /// Brainpool P512r1 curve.
  brainpoolP512R1,

  /// Brainpool P638 curve.
  brainpoolP638,

  /// Curve25519, popular for its security and performance.
  curve25519,

  /// Curve448, known for high security and efficiency.
  curve448,

  /// FRP256v1, a French curve providing strong security and performance.
  frp256V1,
  ;

  static Future<EccCurve> default_() => RustLib.instance.api
      .cryptoLayerCommonCryptoAlgorithmsEncryptionEccCurveDefault();
}

/// Specifies the modes of operation for symmetric block ciphers.
///
/// This enum lists the supported modes of operation, such as GCM, CCM, ECB, CBC, CFB, OFB, and CTR.
/// These modes determine how block ciphers process plaintext and ciphertext, affecting security and performance characteristics.
///
/// # Examples
///
/// Selecting AES in GCM mode:
///
/// ```rust
/// use crypto_layer::common::crypto::algorithms::encryption::SymmetricMode;
///
/// fn main() {
///     let mode = SymmetricMode::Gcm;
/// }
/// ```
///
/// # Note
///
/// `#[repr(C)]` attribute is used for C compatibility.
enum SymmetricMode {
  /// AES in Galois/Counter Mode (GCM) with selectable key sizes.
  /// GCM is preferred for its performance and security, providing both encryption and authentication.
  gcm,

  /// AES in Counter with CBC-MAC (CCM) mode with selectable key sizes.
  /// CCM combines counter mode encryption with CBC-MAC authentication, suitable for constrained environments.
  ccm,

  /// AES in Electronic Codebook (ECB) mode.
  /// ECB encrypts each block of data independently. Due to its deterministic nature, it's considered insecure for most uses.
  ecb,

  /// AES in Cipher Block Chaining (CBC) mode.
  /// CBC mode introduces dependencies between blocks for better security but requires proper IV management.
  cbc,

  /// AES in Cipher Feedback (CFB) mode.
  /// CFB mode turns AES into a stream cipher, allowing for encryption of partial blocks. It's useful for streaming data.
  cfb,

  /// AES in Output Feedback (OFB) mode.
  /// OFB mode also converts AES into a stream cipher but generates keystream blocks independently of the plaintext.
  ofb,

  /// AES in Counter (CTR) mode.
  /// CTR mode encrypts a sequence of counters, offering high throughput and parallelization capabilities.
  ctr,
  ;

  static Future<SymmetricMode> default_() => RustLib.instance.api
      .cryptoLayerCommonCryptoAlgorithmsEncryptionSymmetricModeDefault();
}
