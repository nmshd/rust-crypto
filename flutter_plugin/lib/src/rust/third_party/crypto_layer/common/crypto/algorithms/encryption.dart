// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.3.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../../../frb_generated.dart';
import '../algorithms.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'encryption.freezed.dart';

// These types are ignored because they are not used by any `pub` functions: `ChCha20Mode`, `Rc2KeyBits`, `TripleDesNumKeys`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`

@freezed
sealed class AsymmetricKeySpec with _$AsymmetricKeySpec {
  const AsymmetricKeySpec._();

  /// RSA encryption with selectable key sizes.
  ///
  /// Allows specifying the key size for RSA encryption through the `KeyBits` enum,
  /// supporting various standard key lengths for different security needs. RSA is widely used
  /// for secure data transmission and is known for its simplicity and strong security properties,
  /// provided a sufficiently large key size is used.
  const factory AsymmetricKeySpec.rsa(
    KeyBits field0,
  ) = AsymmetricKeySpec_Rsa;

  /// Represents Elliptic Curve Cryptography (ECC) encryption.
  ///
  /// ECC offers encryption methods based on elliptic curves over finite fields,
  /// potentially including various algorithms and curves such as P-256, P-384, and others.
  /// ECC is known for providing the same level of security as RSA but with smaller key sizes,
  /// leading to faster computations and lower power consumption.
  const factory AsymmetricKeySpec.ecc({
    required EccSigningScheme scheme,
    required EccCurve curve,
  }) = AsymmetricKeySpec_Ecc;
}

/// Specifies the curve types for Elliptic Curve Digital Signature Algorithm (ECDSA).
///
/// Lists the supported elliptic curve specifications for ECDSA, affecting security and performance.
/// Includes both NIST P-curves and others like secp256k1 and Brainpool curves.
///
/// # Examples
///
/// Selecting an ECDSA curve:
///
/// ```
/// use tpm_poc::common::crypto::algorithms::encryption::EccCurve;
///
/// let curve_type = EccCurve::Secp256k1;
/// ```
///
/// # Note
///
/// Uses `#[repr(C)]` for C language compatibility.
enum EccCurve {
  /// NIST P-256 curve.
  p256,

  /// NIST P-384 curve.
  p384,

  /// NIST P-521 curve.
  p521,

  /// secp256k1 curve, commonly used in blockchain technologies.
  secp256K1,

  /// Brainpool P256r1 curve.
  brainpoolP256R1,

  /// Brainpool P384r1 curve.
  brainpoolP384R1,

  /// Brainpool P512r1 curve.
  brainpoolP512R1,

  /// Brainpool P638 curve.
  brainpoolP638,

  /// Curve25519, popular for its security and performance.
  curve25519,

  /// Curve448, known for high security and efficiency.
  curve448,

  /// FRP256v1, a French curve providing strong security and performance.
  frp256V1,
  ;

  static Future<EccCurve> default_() => RustLib.instance.api
      .cryptoLayerCommonCryptoAlgorithmsEncryptionEccCurveDefault();
}

enum EccSigningScheme {
  /// ECDSA: Elliptic Curve Digital Signature Algorithm.
  ecDsa,

  /// ECDAA: Elliptic Curve Direct Anonymous Attestation.
  ecDaa,

  /// EC-Schnorr: A Schnorr signature scheme variant using elliptic curves.
  ecSchnorr,
  ;
}

/// Specifies the modes of operation for symmetric block ciphers.
///
/// This enum lists the supported modes of operation, such as GCM, CCM, ECB, CBC, CFB, OFB, and CTR.
/// These modes determine how block ciphers process plaintext and ciphertext, affecting security and performance characteristics.
///
/// # Examples
///
/// Selecting AES in GCM mode:
///
/// ```rust
/// use tpm_poc::common::crypto::algorithms::encryption::SymmetricMode;
///
/// let mode = SymmetricMode::Gcm;
/// ```
///
/// # Note
///
/// `#[repr(C)]` attribute is used for C compatibility.
enum SymmetricMode {
  /// AES in Galois/Counter Mode (GCM) with selectable key sizes.
  /// GCM is preferred for its performance and security, providing both encryption and authentication.
  gcm,

  /// AES in Counter with CBC-MAC (CCM) mode with selectable key sizes.
  /// CCM combines counter mode encryption with CBC-MAC authentication, suitable for constrained environments.
  ccm,

  /// AES in Electronic Codebook (ECB) mode.
  /// ECB encrypts each block of data independently. Due to its deterministic nature, it's considered insecure for most uses.
  ecb,

  /// AES in Cipher Block Chaining (CBC) mode.
  /// CBC mode introduces dependencies between blocks for better security but requires proper IV management.
  cbc,

  /// AES in Cipher Feedback (CFB) mode.
  /// CFB mode turns AES into a stream cipher, allowing for encryption of partial blocks. It's useful for streaming data.
  cfb,

  /// AES in Output Feedback (OFB) mode.
  /// OFB mode also converts AES into a stream cipher but generates keystream blocks independently of the plaintext.
  ofb,

  /// AES in Counter (CTR) mode.
  /// CTR mode encrypts a sequence of counters, offering high throughput and parallelization capabilities.
  ctr,
  ;

  static Future<SymmetricMode> default_() => RustLib.instance.api
      .cryptoLayerCommonCryptoAlgorithmsEncryptionSymmetricModeDefault();
}
