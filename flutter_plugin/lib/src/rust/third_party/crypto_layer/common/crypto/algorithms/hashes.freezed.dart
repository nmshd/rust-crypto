// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'hashes.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CryptoHash {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sha1,
    required TResult Function(Sha2Bits field0) sha2,
    required TResult Function(Sha3Bits field0) sha3,
    required TResult Function() md2,
    required TResult Function() md4,
    required TResult Function() md5,
    required TResult Function() ripemd160,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sha1,
    TResult? Function(Sha2Bits field0)? sha2,
    TResult? Function(Sha3Bits field0)? sha3,
    TResult? Function()? md2,
    TResult? Function()? md4,
    TResult? Function()? md5,
    TResult? Function()? ripemd160,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sha1,
    TResult Function(Sha2Bits field0)? sha2,
    TResult Function(Sha3Bits field0)? sha3,
    TResult Function()? md2,
    TResult Function()? md4,
    TResult Function()? md5,
    TResult Function()? ripemd160,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoHash_Sha1 value) sha1,
    required TResult Function(CryptoHash_Sha2 value) sha2,
    required TResult Function(CryptoHash_Sha3 value) sha3,
    required TResult Function(CryptoHash_Md2 value) md2,
    required TResult Function(CryptoHash_Md4 value) md4,
    required TResult Function(CryptoHash_Md5 value) md5,
    required TResult Function(CryptoHash_Ripemd160 value) ripemd160,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoHash_Sha1 value)? sha1,
    TResult? Function(CryptoHash_Sha2 value)? sha2,
    TResult? Function(CryptoHash_Sha3 value)? sha3,
    TResult? Function(CryptoHash_Md2 value)? md2,
    TResult? Function(CryptoHash_Md4 value)? md4,
    TResult? Function(CryptoHash_Md5 value)? md5,
    TResult? Function(CryptoHash_Ripemd160 value)? ripemd160,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoHash_Sha1 value)? sha1,
    TResult Function(CryptoHash_Sha2 value)? sha2,
    TResult Function(CryptoHash_Sha3 value)? sha3,
    TResult Function(CryptoHash_Md2 value)? md2,
    TResult Function(CryptoHash_Md4 value)? md4,
    TResult Function(CryptoHash_Md5 value)? md5,
    TResult Function(CryptoHash_Ripemd160 value)? ripemd160,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CryptoHashCopyWith<$Res> {
  factory $CryptoHashCopyWith(
          CryptoHash value, $Res Function(CryptoHash) then) =
      _$CryptoHashCopyWithImpl<$Res, CryptoHash>;
}

/// @nodoc
class _$CryptoHashCopyWithImpl<$Res, $Val extends CryptoHash>
    implements $CryptoHashCopyWith<$Res> {
  _$CryptoHashCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CryptoHash
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$CryptoHash_Sha1ImplCopyWith<$Res> {
  factory _$$CryptoHash_Sha1ImplCopyWith(_$CryptoHash_Sha1Impl value,
          $Res Function(_$CryptoHash_Sha1Impl) then) =
      __$$CryptoHash_Sha1ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CryptoHash_Sha1ImplCopyWithImpl<$Res>
    extends _$CryptoHashCopyWithImpl<$Res, _$CryptoHash_Sha1Impl>
    implements _$$CryptoHash_Sha1ImplCopyWith<$Res> {
  __$$CryptoHash_Sha1ImplCopyWithImpl(
      _$CryptoHash_Sha1Impl _value, $Res Function(_$CryptoHash_Sha1Impl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoHash
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CryptoHash_Sha1Impl extends CryptoHash_Sha1 {
  const _$CryptoHash_Sha1Impl() : super._();

  @override
  String toString() {
    return 'CryptoHash.sha1()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CryptoHash_Sha1Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sha1,
    required TResult Function(Sha2Bits field0) sha2,
    required TResult Function(Sha3Bits field0) sha3,
    required TResult Function() md2,
    required TResult Function() md4,
    required TResult Function() md5,
    required TResult Function() ripemd160,
  }) {
    return sha1();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sha1,
    TResult? Function(Sha2Bits field0)? sha2,
    TResult? Function(Sha3Bits field0)? sha3,
    TResult? Function()? md2,
    TResult? Function()? md4,
    TResult? Function()? md5,
    TResult? Function()? ripemd160,
  }) {
    return sha1?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sha1,
    TResult Function(Sha2Bits field0)? sha2,
    TResult Function(Sha3Bits field0)? sha3,
    TResult Function()? md2,
    TResult Function()? md4,
    TResult Function()? md5,
    TResult Function()? ripemd160,
    required TResult orElse(),
  }) {
    if (sha1 != null) {
      return sha1();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoHash_Sha1 value) sha1,
    required TResult Function(CryptoHash_Sha2 value) sha2,
    required TResult Function(CryptoHash_Sha3 value) sha3,
    required TResult Function(CryptoHash_Md2 value) md2,
    required TResult Function(CryptoHash_Md4 value) md4,
    required TResult Function(CryptoHash_Md5 value) md5,
    required TResult Function(CryptoHash_Ripemd160 value) ripemd160,
  }) {
    return sha1(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoHash_Sha1 value)? sha1,
    TResult? Function(CryptoHash_Sha2 value)? sha2,
    TResult? Function(CryptoHash_Sha3 value)? sha3,
    TResult? Function(CryptoHash_Md2 value)? md2,
    TResult? Function(CryptoHash_Md4 value)? md4,
    TResult? Function(CryptoHash_Md5 value)? md5,
    TResult? Function(CryptoHash_Ripemd160 value)? ripemd160,
  }) {
    return sha1?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoHash_Sha1 value)? sha1,
    TResult Function(CryptoHash_Sha2 value)? sha2,
    TResult Function(CryptoHash_Sha3 value)? sha3,
    TResult Function(CryptoHash_Md2 value)? md2,
    TResult Function(CryptoHash_Md4 value)? md4,
    TResult Function(CryptoHash_Md5 value)? md5,
    TResult Function(CryptoHash_Ripemd160 value)? ripemd160,
    required TResult orElse(),
  }) {
    if (sha1 != null) {
      return sha1(this);
    }
    return orElse();
  }
}

abstract class CryptoHash_Sha1 extends CryptoHash {
  const factory CryptoHash_Sha1() = _$CryptoHash_Sha1Impl;
  const CryptoHash_Sha1._() : super._();
}

/// @nodoc
abstract class _$$CryptoHash_Sha2ImplCopyWith<$Res> {
  factory _$$CryptoHash_Sha2ImplCopyWith(_$CryptoHash_Sha2Impl value,
          $Res Function(_$CryptoHash_Sha2Impl) then) =
      __$$CryptoHash_Sha2ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Sha2Bits field0});
}

/// @nodoc
class __$$CryptoHash_Sha2ImplCopyWithImpl<$Res>
    extends _$CryptoHashCopyWithImpl<$Res, _$CryptoHash_Sha2Impl>
    implements _$$CryptoHash_Sha2ImplCopyWith<$Res> {
  __$$CryptoHash_Sha2ImplCopyWithImpl(
      _$CryptoHash_Sha2Impl _value, $Res Function(_$CryptoHash_Sha2Impl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoHash
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$CryptoHash_Sha2Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Sha2Bits,
    ));
  }
}

/// @nodoc

class _$CryptoHash_Sha2Impl extends CryptoHash_Sha2 {
  const _$CryptoHash_Sha2Impl(this.field0) : super._();

  @override
  final Sha2Bits field0;

  @override
  String toString() {
    return 'CryptoHash.sha2(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoHash_Sha2Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of CryptoHash
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CryptoHash_Sha2ImplCopyWith<_$CryptoHash_Sha2Impl> get copyWith =>
      __$$CryptoHash_Sha2ImplCopyWithImpl<_$CryptoHash_Sha2Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sha1,
    required TResult Function(Sha2Bits field0) sha2,
    required TResult Function(Sha3Bits field0) sha3,
    required TResult Function() md2,
    required TResult Function() md4,
    required TResult Function() md5,
    required TResult Function() ripemd160,
  }) {
    return sha2(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sha1,
    TResult? Function(Sha2Bits field0)? sha2,
    TResult? Function(Sha3Bits field0)? sha3,
    TResult? Function()? md2,
    TResult? Function()? md4,
    TResult? Function()? md5,
    TResult? Function()? ripemd160,
  }) {
    return sha2?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sha1,
    TResult Function(Sha2Bits field0)? sha2,
    TResult Function(Sha3Bits field0)? sha3,
    TResult Function()? md2,
    TResult Function()? md4,
    TResult Function()? md5,
    TResult Function()? ripemd160,
    required TResult orElse(),
  }) {
    if (sha2 != null) {
      return sha2(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoHash_Sha1 value) sha1,
    required TResult Function(CryptoHash_Sha2 value) sha2,
    required TResult Function(CryptoHash_Sha3 value) sha3,
    required TResult Function(CryptoHash_Md2 value) md2,
    required TResult Function(CryptoHash_Md4 value) md4,
    required TResult Function(CryptoHash_Md5 value) md5,
    required TResult Function(CryptoHash_Ripemd160 value) ripemd160,
  }) {
    return sha2(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoHash_Sha1 value)? sha1,
    TResult? Function(CryptoHash_Sha2 value)? sha2,
    TResult? Function(CryptoHash_Sha3 value)? sha3,
    TResult? Function(CryptoHash_Md2 value)? md2,
    TResult? Function(CryptoHash_Md4 value)? md4,
    TResult? Function(CryptoHash_Md5 value)? md5,
    TResult? Function(CryptoHash_Ripemd160 value)? ripemd160,
  }) {
    return sha2?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoHash_Sha1 value)? sha1,
    TResult Function(CryptoHash_Sha2 value)? sha2,
    TResult Function(CryptoHash_Sha3 value)? sha3,
    TResult Function(CryptoHash_Md2 value)? md2,
    TResult Function(CryptoHash_Md4 value)? md4,
    TResult Function(CryptoHash_Md5 value)? md5,
    TResult Function(CryptoHash_Ripemd160 value)? ripemd160,
    required TResult orElse(),
  }) {
    if (sha2 != null) {
      return sha2(this);
    }
    return orElse();
  }
}

abstract class CryptoHash_Sha2 extends CryptoHash {
  const factory CryptoHash_Sha2(final Sha2Bits field0) = _$CryptoHash_Sha2Impl;
  const CryptoHash_Sha2._() : super._();

  Sha2Bits get field0;

  /// Create a copy of CryptoHash
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CryptoHash_Sha2ImplCopyWith<_$CryptoHash_Sha2Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CryptoHash_Sha3ImplCopyWith<$Res> {
  factory _$$CryptoHash_Sha3ImplCopyWith(_$CryptoHash_Sha3Impl value,
          $Res Function(_$CryptoHash_Sha3Impl) then) =
      __$$CryptoHash_Sha3ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Sha3Bits field0});
}

/// @nodoc
class __$$CryptoHash_Sha3ImplCopyWithImpl<$Res>
    extends _$CryptoHashCopyWithImpl<$Res, _$CryptoHash_Sha3Impl>
    implements _$$CryptoHash_Sha3ImplCopyWith<$Res> {
  __$$CryptoHash_Sha3ImplCopyWithImpl(
      _$CryptoHash_Sha3Impl _value, $Res Function(_$CryptoHash_Sha3Impl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoHash
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$CryptoHash_Sha3Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Sha3Bits,
    ));
  }
}

/// @nodoc

class _$CryptoHash_Sha3Impl extends CryptoHash_Sha3 {
  const _$CryptoHash_Sha3Impl(this.field0) : super._();

  @override
  final Sha3Bits field0;

  @override
  String toString() {
    return 'CryptoHash.sha3(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoHash_Sha3Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of CryptoHash
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CryptoHash_Sha3ImplCopyWith<_$CryptoHash_Sha3Impl> get copyWith =>
      __$$CryptoHash_Sha3ImplCopyWithImpl<_$CryptoHash_Sha3Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sha1,
    required TResult Function(Sha2Bits field0) sha2,
    required TResult Function(Sha3Bits field0) sha3,
    required TResult Function() md2,
    required TResult Function() md4,
    required TResult Function() md5,
    required TResult Function() ripemd160,
  }) {
    return sha3(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sha1,
    TResult? Function(Sha2Bits field0)? sha2,
    TResult? Function(Sha3Bits field0)? sha3,
    TResult? Function()? md2,
    TResult? Function()? md4,
    TResult? Function()? md5,
    TResult? Function()? ripemd160,
  }) {
    return sha3?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sha1,
    TResult Function(Sha2Bits field0)? sha2,
    TResult Function(Sha3Bits field0)? sha3,
    TResult Function()? md2,
    TResult Function()? md4,
    TResult Function()? md5,
    TResult Function()? ripemd160,
    required TResult orElse(),
  }) {
    if (sha3 != null) {
      return sha3(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoHash_Sha1 value) sha1,
    required TResult Function(CryptoHash_Sha2 value) sha2,
    required TResult Function(CryptoHash_Sha3 value) sha3,
    required TResult Function(CryptoHash_Md2 value) md2,
    required TResult Function(CryptoHash_Md4 value) md4,
    required TResult Function(CryptoHash_Md5 value) md5,
    required TResult Function(CryptoHash_Ripemd160 value) ripemd160,
  }) {
    return sha3(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoHash_Sha1 value)? sha1,
    TResult? Function(CryptoHash_Sha2 value)? sha2,
    TResult? Function(CryptoHash_Sha3 value)? sha3,
    TResult? Function(CryptoHash_Md2 value)? md2,
    TResult? Function(CryptoHash_Md4 value)? md4,
    TResult? Function(CryptoHash_Md5 value)? md5,
    TResult? Function(CryptoHash_Ripemd160 value)? ripemd160,
  }) {
    return sha3?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoHash_Sha1 value)? sha1,
    TResult Function(CryptoHash_Sha2 value)? sha2,
    TResult Function(CryptoHash_Sha3 value)? sha3,
    TResult Function(CryptoHash_Md2 value)? md2,
    TResult Function(CryptoHash_Md4 value)? md4,
    TResult Function(CryptoHash_Md5 value)? md5,
    TResult Function(CryptoHash_Ripemd160 value)? ripemd160,
    required TResult orElse(),
  }) {
    if (sha3 != null) {
      return sha3(this);
    }
    return orElse();
  }
}

abstract class CryptoHash_Sha3 extends CryptoHash {
  const factory CryptoHash_Sha3(final Sha3Bits field0) = _$CryptoHash_Sha3Impl;
  const CryptoHash_Sha3._() : super._();

  Sha3Bits get field0;

  /// Create a copy of CryptoHash
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CryptoHash_Sha3ImplCopyWith<_$CryptoHash_Sha3Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CryptoHash_Md2ImplCopyWith<$Res> {
  factory _$$CryptoHash_Md2ImplCopyWith(_$CryptoHash_Md2Impl value,
          $Res Function(_$CryptoHash_Md2Impl) then) =
      __$$CryptoHash_Md2ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CryptoHash_Md2ImplCopyWithImpl<$Res>
    extends _$CryptoHashCopyWithImpl<$Res, _$CryptoHash_Md2Impl>
    implements _$$CryptoHash_Md2ImplCopyWith<$Res> {
  __$$CryptoHash_Md2ImplCopyWithImpl(
      _$CryptoHash_Md2Impl _value, $Res Function(_$CryptoHash_Md2Impl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoHash
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CryptoHash_Md2Impl extends CryptoHash_Md2 {
  const _$CryptoHash_Md2Impl() : super._();

  @override
  String toString() {
    return 'CryptoHash.md2()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CryptoHash_Md2Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sha1,
    required TResult Function(Sha2Bits field0) sha2,
    required TResult Function(Sha3Bits field0) sha3,
    required TResult Function() md2,
    required TResult Function() md4,
    required TResult Function() md5,
    required TResult Function() ripemd160,
  }) {
    return md2();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sha1,
    TResult? Function(Sha2Bits field0)? sha2,
    TResult? Function(Sha3Bits field0)? sha3,
    TResult? Function()? md2,
    TResult? Function()? md4,
    TResult? Function()? md5,
    TResult? Function()? ripemd160,
  }) {
    return md2?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sha1,
    TResult Function(Sha2Bits field0)? sha2,
    TResult Function(Sha3Bits field0)? sha3,
    TResult Function()? md2,
    TResult Function()? md4,
    TResult Function()? md5,
    TResult Function()? ripemd160,
    required TResult orElse(),
  }) {
    if (md2 != null) {
      return md2();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoHash_Sha1 value) sha1,
    required TResult Function(CryptoHash_Sha2 value) sha2,
    required TResult Function(CryptoHash_Sha3 value) sha3,
    required TResult Function(CryptoHash_Md2 value) md2,
    required TResult Function(CryptoHash_Md4 value) md4,
    required TResult Function(CryptoHash_Md5 value) md5,
    required TResult Function(CryptoHash_Ripemd160 value) ripemd160,
  }) {
    return md2(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoHash_Sha1 value)? sha1,
    TResult? Function(CryptoHash_Sha2 value)? sha2,
    TResult? Function(CryptoHash_Sha3 value)? sha3,
    TResult? Function(CryptoHash_Md2 value)? md2,
    TResult? Function(CryptoHash_Md4 value)? md4,
    TResult? Function(CryptoHash_Md5 value)? md5,
    TResult? Function(CryptoHash_Ripemd160 value)? ripemd160,
  }) {
    return md2?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoHash_Sha1 value)? sha1,
    TResult Function(CryptoHash_Sha2 value)? sha2,
    TResult Function(CryptoHash_Sha3 value)? sha3,
    TResult Function(CryptoHash_Md2 value)? md2,
    TResult Function(CryptoHash_Md4 value)? md4,
    TResult Function(CryptoHash_Md5 value)? md5,
    TResult Function(CryptoHash_Ripemd160 value)? ripemd160,
    required TResult orElse(),
  }) {
    if (md2 != null) {
      return md2(this);
    }
    return orElse();
  }
}

abstract class CryptoHash_Md2 extends CryptoHash {
  const factory CryptoHash_Md2() = _$CryptoHash_Md2Impl;
  const CryptoHash_Md2._() : super._();
}

/// @nodoc
abstract class _$$CryptoHash_Md4ImplCopyWith<$Res> {
  factory _$$CryptoHash_Md4ImplCopyWith(_$CryptoHash_Md4Impl value,
          $Res Function(_$CryptoHash_Md4Impl) then) =
      __$$CryptoHash_Md4ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CryptoHash_Md4ImplCopyWithImpl<$Res>
    extends _$CryptoHashCopyWithImpl<$Res, _$CryptoHash_Md4Impl>
    implements _$$CryptoHash_Md4ImplCopyWith<$Res> {
  __$$CryptoHash_Md4ImplCopyWithImpl(
      _$CryptoHash_Md4Impl _value, $Res Function(_$CryptoHash_Md4Impl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoHash
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CryptoHash_Md4Impl extends CryptoHash_Md4 {
  const _$CryptoHash_Md4Impl() : super._();

  @override
  String toString() {
    return 'CryptoHash.md4()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CryptoHash_Md4Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sha1,
    required TResult Function(Sha2Bits field0) sha2,
    required TResult Function(Sha3Bits field0) sha3,
    required TResult Function() md2,
    required TResult Function() md4,
    required TResult Function() md5,
    required TResult Function() ripemd160,
  }) {
    return md4();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sha1,
    TResult? Function(Sha2Bits field0)? sha2,
    TResult? Function(Sha3Bits field0)? sha3,
    TResult? Function()? md2,
    TResult? Function()? md4,
    TResult? Function()? md5,
    TResult? Function()? ripemd160,
  }) {
    return md4?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sha1,
    TResult Function(Sha2Bits field0)? sha2,
    TResult Function(Sha3Bits field0)? sha3,
    TResult Function()? md2,
    TResult Function()? md4,
    TResult Function()? md5,
    TResult Function()? ripemd160,
    required TResult orElse(),
  }) {
    if (md4 != null) {
      return md4();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoHash_Sha1 value) sha1,
    required TResult Function(CryptoHash_Sha2 value) sha2,
    required TResult Function(CryptoHash_Sha3 value) sha3,
    required TResult Function(CryptoHash_Md2 value) md2,
    required TResult Function(CryptoHash_Md4 value) md4,
    required TResult Function(CryptoHash_Md5 value) md5,
    required TResult Function(CryptoHash_Ripemd160 value) ripemd160,
  }) {
    return md4(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoHash_Sha1 value)? sha1,
    TResult? Function(CryptoHash_Sha2 value)? sha2,
    TResult? Function(CryptoHash_Sha3 value)? sha3,
    TResult? Function(CryptoHash_Md2 value)? md2,
    TResult? Function(CryptoHash_Md4 value)? md4,
    TResult? Function(CryptoHash_Md5 value)? md5,
    TResult? Function(CryptoHash_Ripemd160 value)? ripemd160,
  }) {
    return md4?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoHash_Sha1 value)? sha1,
    TResult Function(CryptoHash_Sha2 value)? sha2,
    TResult Function(CryptoHash_Sha3 value)? sha3,
    TResult Function(CryptoHash_Md2 value)? md2,
    TResult Function(CryptoHash_Md4 value)? md4,
    TResult Function(CryptoHash_Md5 value)? md5,
    TResult Function(CryptoHash_Ripemd160 value)? ripemd160,
    required TResult orElse(),
  }) {
    if (md4 != null) {
      return md4(this);
    }
    return orElse();
  }
}

abstract class CryptoHash_Md4 extends CryptoHash {
  const factory CryptoHash_Md4() = _$CryptoHash_Md4Impl;
  const CryptoHash_Md4._() : super._();
}

/// @nodoc
abstract class _$$CryptoHash_Md5ImplCopyWith<$Res> {
  factory _$$CryptoHash_Md5ImplCopyWith(_$CryptoHash_Md5Impl value,
          $Res Function(_$CryptoHash_Md5Impl) then) =
      __$$CryptoHash_Md5ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CryptoHash_Md5ImplCopyWithImpl<$Res>
    extends _$CryptoHashCopyWithImpl<$Res, _$CryptoHash_Md5Impl>
    implements _$$CryptoHash_Md5ImplCopyWith<$Res> {
  __$$CryptoHash_Md5ImplCopyWithImpl(
      _$CryptoHash_Md5Impl _value, $Res Function(_$CryptoHash_Md5Impl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoHash
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CryptoHash_Md5Impl extends CryptoHash_Md5 {
  const _$CryptoHash_Md5Impl() : super._();

  @override
  String toString() {
    return 'CryptoHash.md5()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CryptoHash_Md5Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sha1,
    required TResult Function(Sha2Bits field0) sha2,
    required TResult Function(Sha3Bits field0) sha3,
    required TResult Function() md2,
    required TResult Function() md4,
    required TResult Function() md5,
    required TResult Function() ripemd160,
  }) {
    return md5();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sha1,
    TResult? Function(Sha2Bits field0)? sha2,
    TResult? Function(Sha3Bits field0)? sha3,
    TResult? Function()? md2,
    TResult? Function()? md4,
    TResult? Function()? md5,
    TResult? Function()? ripemd160,
  }) {
    return md5?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sha1,
    TResult Function(Sha2Bits field0)? sha2,
    TResult Function(Sha3Bits field0)? sha3,
    TResult Function()? md2,
    TResult Function()? md4,
    TResult Function()? md5,
    TResult Function()? ripemd160,
    required TResult orElse(),
  }) {
    if (md5 != null) {
      return md5();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoHash_Sha1 value) sha1,
    required TResult Function(CryptoHash_Sha2 value) sha2,
    required TResult Function(CryptoHash_Sha3 value) sha3,
    required TResult Function(CryptoHash_Md2 value) md2,
    required TResult Function(CryptoHash_Md4 value) md4,
    required TResult Function(CryptoHash_Md5 value) md5,
    required TResult Function(CryptoHash_Ripemd160 value) ripemd160,
  }) {
    return md5(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoHash_Sha1 value)? sha1,
    TResult? Function(CryptoHash_Sha2 value)? sha2,
    TResult? Function(CryptoHash_Sha3 value)? sha3,
    TResult? Function(CryptoHash_Md2 value)? md2,
    TResult? Function(CryptoHash_Md4 value)? md4,
    TResult? Function(CryptoHash_Md5 value)? md5,
    TResult? Function(CryptoHash_Ripemd160 value)? ripemd160,
  }) {
    return md5?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoHash_Sha1 value)? sha1,
    TResult Function(CryptoHash_Sha2 value)? sha2,
    TResult Function(CryptoHash_Sha3 value)? sha3,
    TResult Function(CryptoHash_Md2 value)? md2,
    TResult Function(CryptoHash_Md4 value)? md4,
    TResult Function(CryptoHash_Md5 value)? md5,
    TResult Function(CryptoHash_Ripemd160 value)? ripemd160,
    required TResult orElse(),
  }) {
    if (md5 != null) {
      return md5(this);
    }
    return orElse();
  }
}

abstract class CryptoHash_Md5 extends CryptoHash {
  const factory CryptoHash_Md5() = _$CryptoHash_Md5Impl;
  const CryptoHash_Md5._() : super._();
}

/// @nodoc
abstract class _$$CryptoHash_Ripemd160ImplCopyWith<$Res> {
  factory _$$CryptoHash_Ripemd160ImplCopyWith(_$CryptoHash_Ripemd160Impl value,
          $Res Function(_$CryptoHash_Ripemd160Impl) then) =
      __$$CryptoHash_Ripemd160ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CryptoHash_Ripemd160ImplCopyWithImpl<$Res>
    extends _$CryptoHashCopyWithImpl<$Res, _$CryptoHash_Ripemd160Impl>
    implements _$$CryptoHash_Ripemd160ImplCopyWith<$Res> {
  __$$CryptoHash_Ripemd160ImplCopyWithImpl(_$CryptoHash_Ripemd160Impl _value,
      $Res Function(_$CryptoHash_Ripemd160Impl) _then)
      : super(_value, _then);

  /// Create a copy of CryptoHash
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CryptoHash_Ripemd160Impl extends CryptoHash_Ripemd160 {
  const _$CryptoHash_Ripemd160Impl() : super._();

  @override
  String toString() {
    return 'CryptoHash.ripemd160()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoHash_Ripemd160Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sha1,
    required TResult Function(Sha2Bits field0) sha2,
    required TResult Function(Sha3Bits field0) sha3,
    required TResult Function() md2,
    required TResult Function() md4,
    required TResult Function() md5,
    required TResult Function() ripemd160,
  }) {
    return ripemd160();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sha1,
    TResult? Function(Sha2Bits field0)? sha2,
    TResult? Function(Sha3Bits field0)? sha3,
    TResult? Function()? md2,
    TResult? Function()? md4,
    TResult? Function()? md5,
    TResult? Function()? ripemd160,
  }) {
    return ripemd160?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sha1,
    TResult Function(Sha2Bits field0)? sha2,
    TResult Function(Sha3Bits field0)? sha3,
    TResult Function()? md2,
    TResult Function()? md4,
    TResult Function()? md5,
    TResult Function()? ripemd160,
    required TResult orElse(),
  }) {
    if (ripemd160 != null) {
      return ripemd160();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CryptoHash_Sha1 value) sha1,
    required TResult Function(CryptoHash_Sha2 value) sha2,
    required TResult Function(CryptoHash_Sha3 value) sha3,
    required TResult Function(CryptoHash_Md2 value) md2,
    required TResult Function(CryptoHash_Md4 value) md4,
    required TResult Function(CryptoHash_Md5 value) md5,
    required TResult Function(CryptoHash_Ripemd160 value) ripemd160,
  }) {
    return ripemd160(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CryptoHash_Sha1 value)? sha1,
    TResult? Function(CryptoHash_Sha2 value)? sha2,
    TResult? Function(CryptoHash_Sha3 value)? sha3,
    TResult? Function(CryptoHash_Md2 value)? md2,
    TResult? Function(CryptoHash_Md4 value)? md4,
    TResult? Function(CryptoHash_Md5 value)? md5,
    TResult? Function(CryptoHash_Ripemd160 value)? ripemd160,
  }) {
    return ripemd160?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CryptoHash_Sha1 value)? sha1,
    TResult Function(CryptoHash_Sha2 value)? sha2,
    TResult Function(CryptoHash_Sha3 value)? sha3,
    TResult Function(CryptoHash_Md2 value)? md2,
    TResult Function(CryptoHash_Md4 value)? md4,
    TResult Function(CryptoHash_Md5 value)? md5,
    TResult Function(CryptoHash_Ripemd160 value)? ripemd160,
    required TResult orElse(),
  }) {
    if (ripemd160 != null) {
      return ripemd160(this);
    }
    return orElse();
  }
}

abstract class CryptoHash_Ripemd160 extends CryptoHash {
  const factory CryptoHash_Ripemd160() = _$CryptoHash_Ripemd160Impl;
  const CryptoHash_Ripemd160._() : super._();
}
