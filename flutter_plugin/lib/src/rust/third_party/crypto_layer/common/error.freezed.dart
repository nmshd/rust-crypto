// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CalErrorKind {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notImplemented,
    required TResult Function(String description, bool internal) badParameter,
    required TResult Function(String keyId, KeyType keyType) missingKey,
    required TResult Function(String description, bool internal) missingValue,
    required TResult Function(String description, bool internal)
        failedOperation,
    required TResult Function(String description, bool internal)
        initializationError,
    required TResult Function(String field0) unsupportedAlgorithm,
    required TResult Function() other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notImplemented,
    TResult? Function(String description, bool internal)? badParameter,
    TResult? Function(String keyId, KeyType keyType)? missingKey,
    TResult? Function(String description, bool internal)? missingValue,
    TResult? Function(String description, bool internal)? failedOperation,
    TResult? Function(String description, bool internal)? initializationError,
    TResult? Function(String field0)? unsupportedAlgorithm,
    TResult? Function()? other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notImplemented,
    TResult Function(String description, bool internal)? badParameter,
    TResult Function(String keyId, KeyType keyType)? missingKey,
    TResult Function(String description, bool internal)? missingValue,
    TResult Function(String description, bool internal)? failedOperation,
    TResult Function(String description, bool internal)? initializationError,
    TResult Function(String field0)? unsupportedAlgorithm,
    TResult Function()? other,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalErrorKind_NotImplemented value) notImplemented,
    required TResult Function(CalErrorKind_BadParameter value) badParameter,
    required TResult Function(CalErrorKind_MissingKey value) missingKey,
    required TResult Function(CalErrorKind_MissingValue value) missingValue,
    required TResult Function(CalErrorKind_FailedOperation value)
        failedOperation,
    required TResult Function(CalErrorKind_InitializationError value)
        initializationError,
    required TResult Function(CalErrorKind_UnsupportedAlgorithm value)
        unsupportedAlgorithm,
    required TResult Function(CalErrorKind_Other value) other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult? Function(CalErrorKind_BadParameter value)? badParameter,
    TResult? Function(CalErrorKind_MissingKey value)? missingKey,
    TResult? Function(CalErrorKind_MissingValue value)? missingValue,
    TResult? Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult? Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult? Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult? Function(CalErrorKind_Other value)? other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult Function(CalErrorKind_BadParameter value)? badParameter,
    TResult Function(CalErrorKind_MissingKey value)? missingKey,
    TResult Function(CalErrorKind_MissingValue value)? missingValue,
    TResult Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult Function(CalErrorKind_Other value)? other,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CalErrorKindCopyWith<$Res> {
  factory $CalErrorKindCopyWith(
          CalErrorKind value, $Res Function(CalErrorKind) then) =
      _$CalErrorKindCopyWithImpl<$Res, CalErrorKind>;
}

/// @nodoc
class _$CalErrorKindCopyWithImpl<$Res, $Val extends CalErrorKind>
    implements $CalErrorKindCopyWith<$Res> {
  _$CalErrorKindCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$CalErrorKind_NotImplementedImplCopyWith<$Res> {
  factory _$$CalErrorKind_NotImplementedImplCopyWith(
          _$CalErrorKind_NotImplementedImpl value,
          $Res Function(_$CalErrorKind_NotImplementedImpl) then) =
      __$$CalErrorKind_NotImplementedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CalErrorKind_NotImplementedImplCopyWithImpl<$Res>
    extends _$CalErrorKindCopyWithImpl<$Res, _$CalErrorKind_NotImplementedImpl>
    implements _$$CalErrorKind_NotImplementedImplCopyWith<$Res> {
  __$$CalErrorKind_NotImplementedImplCopyWithImpl(
      _$CalErrorKind_NotImplementedImpl _value,
      $Res Function(_$CalErrorKind_NotImplementedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CalErrorKind_NotImplementedImpl extends CalErrorKind_NotImplemented {
  const _$CalErrorKind_NotImplementedImpl() : super._();

  @override
  String toString() {
    return 'CalErrorKind.notImplemented()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalErrorKind_NotImplementedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notImplemented,
    required TResult Function(String description, bool internal) badParameter,
    required TResult Function(String keyId, KeyType keyType) missingKey,
    required TResult Function(String description, bool internal) missingValue,
    required TResult Function(String description, bool internal)
        failedOperation,
    required TResult Function(String description, bool internal)
        initializationError,
    required TResult Function(String field0) unsupportedAlgorithm,
    required TResult Function() other,
  }) {
    return notImplemented();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notImplemented,
    TResult? Function(String description, bool internal)? badParameter,
    TResult? Function(String keyId, KeyType keyType)? missingKey,
    TResult? Function(String description, bool internal)? missingValue,
    TResult? Function(String description, bool internal)? failedOperation,
    TResult? Function(String description, bool internal)? initializationError,
    TResult? Function(String field0)? unsupportedAlgorithm,
    TResult? Function()? other,
  }) {
    return notImplemented?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notImplemented,
    TResult Function(String description, bool internal)? badParameter,
    TResult Function(String keyId, KeyType keyType)? missingKey,
    TResult Function(String description, bool internal)? missingValue,
    TResult Function(String description, bool internal)? failedOperation,
    TResult Function(String description, bool internal)? initializationError,
    TResult Function(String field0)? unsupportedAlgorithm,
    TResult Function()? other,
    required TResult orElse(),
  }) {
    if (notImplemented != null) {
      return notImplemented();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalErrorKind_NotImplemented value) notImplemented,
    required TResult Function(CalErrorKind_BadParameter value) badParameter,
    required TResult Function(CalErrorKind_MissingKey value) missingKey,
    required TResult Function(CalErrorKind_MissingValue value) missingValue,
    required TResult Function(CalErrorKind_FailedOperation value)
        failedOperation,
    required TResult Function(CalErrorKind_InitializationError value)
        initializationError,
    required TResult Function(CalErrorKind_UnsupportedAlgorithm value)
        unsupportedAlgorithm,
    required TResult Function(CalErrorKind_Other value) other,
  }) {
    return notImplemented(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult? Function(CalErrorKind_BadParameter value)? badParameter,
    TResult? Function(CalErrorKind_MissingKey value)? missingKey,
    TResult? Function(CalErrorKind_MissingValue value)? missingValue,
    TResult? Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult? Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult? Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult? Function(CalErrorKind_Other value)? other,
  }) {
    return notImplemented?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult Function(CalErrorKind_BadParameter value)? badParameter,
    TResult Function(CalErrorKind_MissingKey value)? missingKey,
    TResult Function(CalErrorKind_MissingValue value)? missingValue,
    TResult Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult Function(CalErrorKind_Other value)? other,
    required TResult orElse(),
  }) {
    if (notImplemented != null) {
      return notImplemented(this);
    }
    return orElse();
  }
}

abstract class CalErrorKind_NotImplemented extends CalErrorKind {
  const factory CalErrorKind_NotImplemented() =
      _$CalErrorKind_NotImplementedImpl;
  const CalErrorKind_NotImplemented._() : super._();
}

/// @nodoc
abstract class _$$CalErrorKind_BadParameterImplCopyWith<$Res> {
  factory _$$CalErrorKind_BadParameterImplCopyWith(
          _$CalErrorKind_BadParameterImpl value,
          $Res Function(_$CalErrorKind_BadParameterImpl) then) =
      __$$CalErrorKind_BadParameterImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String description, bool internal});
}

/// @nodoc
class __$$CalErrorKind_BadParameterImplCopyWithImpl<$Res>
    extends _$CalErrorKindCopyWithImpl<$Res, _$CalErrorKind_BadParameterImpl>
    implements _$$CalErrorKind_BadParameterImplCopyWith<$Res> {
  __$$CalErrorKind_BadParameterImplCopyWithImpl(
      _$CalErrorKind_BadParameterImpl _value,
      $Res Function(_$CalErrorKind_BadParameterImpl) _then)
      : super(_value, _then);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
    Object? internal = null,
  }) {
    return _then(_$CalErrorKind_BadParameterImpl(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      internal: null == internal
          ? _value.internal
          : internal // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$CalErrorKind_BadParameterImpl extends CalErrorKind_BadParameter {
  const _$CalErrorKind_BadParameterImpl(
      {required this.description, required this.internal})
      : super._();

  @override
  final String description;

  /// `true` if caused within this library. `false` if caused by another library.
  @override
  final bool internal;

  @override
  String toString() {
    return 'CalErrorKind.badParameter(description: $description, internal: $internal)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalErrorKind_BadParameterImpl &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.internal, internal) ||
                other.internal == internal));
  }

  @override
  int get hashCode => Object.hash(runtimeType, description, internal);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CalErrorKind_BadParameterImplCopyWith<_$CalErrorKind_BadParameterImpl>
      get copyWith => __$$CalErrorKind_BadParameterImplCopyWithImpl<
          _$CalErrorKind_BadParameterImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notImplemented,
    required TResult Function(String description, bool internal) badParameter,
    required TResult Function(String keyId, KeyType keyType) missingKey,
    required TResult Function(String description, bool internal) missingValue,
    required TResult Function(String description, bool internal)
        failedOperation,
    required TResult Function(String description, bool internal)
        initializationError,
    required TResult Function(String field0) unsupportedAlgorithm,
    required TResult Function() other,
  }) {
    return badParameter(description, internal);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notImplemented,
    TResult? Function(String description, bool internal)? badParameter,
    TResult? Function(String keyId, KeyType keyType)? missingKey,
    TResult? Function(String description, bool internal)? missingValue,
    TResult? Function(String description, bool internal)? failedOperation,
    TResult? Function(String description, bool internal)? initializationError,
    TResult? Function(String field0)? unsupportedAlgorithm,
    TResult? Function()? other,
  }) {
    return badParameter?.call(description, internal);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notImplemented,
    TResult Function(String description, bool internal)? badParameter,
    TResult Function(String keyId, KeyType keyType)? missingKey,
    TResult Function(String description, bool internal)? missingValue,
    TResult Function(String description, bool internal)? failedOperation,
    TResult Function(String description, bool internal)? initializationError,
    TResult Function(String field0)? unsupportedAlgorithm,
    TResult Function()? other,
    required TResult orElse(),
  }) {
    if (badParameter != null) {
      return badParameter(description, internal);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalErrorKind_NotImplemented value) notImplemented,
    required TResult Function(CalErrorKind_BadParameter value) badParameter,
    required TResult Function(CalErrorKind_MissingKey value) missingKey,
    required TResult Function(CalErrorKind_MissingValue value) missingValue,
    required TResult Function(CalErrorKind_FailedOperation value)
        failedOperation,
    required TResult Function(CalErrorKind_InitializationError value)
        initializationError,
    required TResult Function(CalErrorKind_UnsupportedAlgorithm value)
        unsupportedAlgorithm,
    required TResult Function(CalErrorKind_Other value) other,
  }) {
    return badParameter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult? Function(CalErrorKind_BadParameter value)? badParameter,
    TResult? Function(CalErrorKind_MissingKey value)? missingKey,
    TResult? Function(CalErrorKind_MissingValue value)? missingValue,
    TResult? Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult? Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult? Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult? Function(CalErrorKind_Other value)? other,
  }) {
    return badParameter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult Function(CalErrorKind_BadParameter value)? badParameter,
    TResult Function(CalErrorKind_MissingKey value)? missingKey,
    TResult Function(CalErrorKind_MissingValue value)? missingValue,
    TResult Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult Function(CalErrorKind_Other value)? other,
    required TResult orElse(),
  }) {
    if (badParameter != null) {
      return badParameter(this);
    }
    return orElse();
  }
}

abstract class CalErrorKind_BadParameter extends CalErrorKind {
  const factory CalErrorKind_BadParameter(
      {required final String description,
      required final bool internal}) = _$CalErrorKind_BadParameterImpl;
  const CalErrorKind_BadParameter._() : super._();

  String get description;

  /// `true` if caused within this library. `false` if caused by another library.
  bool get internal;

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CalErrorKind_BadParameterImplCopyWith<_$CalErrorKind_BadParameterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CalErrorKind_MissingKeyImplCopyWith<$Res> {
  factory _$$CalErrorKind_MissingKeyImplCopyWith(
          _$CalErrorKind_MissingKeyImpl value,
          $Res Function(_$CalErrorKind_MissingKeyImpl) then) =
      __$$CalErrorKind_MissingKeyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String keyId, KeyType keyType});
}

/// @nodoc
class __$$CalErrorKind_MissingKeyImplCopyWithImpl<$Res>
    extends _$CalErrorKindCopyWithImpl<$Res, _$CalErrorKind_MissingKeyImpl>
    implements _$$CalErrorKind_MissingKeyImplCopyWith<$Res> {
  __$$CalErrorKind_MissingKeyImplCopyWithImpl(
      _$CalErrorKind_MissingKeyImpl _value,
      $Res Function(_$CalErrorKind_MissingKeyImpl) _then)
      : super(_value, _then);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? keyId = null,
    Object? keyType = null,
  }) {
    return _then(_$CalErrorKind_MissingKeyImpl(
      keyId: null == keyId
          ? _value.keyId
          : keyId // ignore: cast_nullable_to_non_nullable
              as String,
      keyType: null == keyType
          ? _value.keyType
          : keyType // ignore: cast_nullable_to_non_nullable
              as KeyType,
    ));
  }
}

/// @nodoc

class _$CalErrorKind_MissingKeyImpl extends CalErrorKind_MissingKey {
  const _$CalErrorKind_MissingKeyImpl(
      {required this.keyId, required this.keyType})
      : super._();

  @override
  final String keyId;
  @override
  final KeyType keyType;

  @override
  String toString() {
    return 'CalErrorKind.missingKey(keyId: $keyId, keyType: $keyType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalErrorKind_MissingKeyImpl &&
            (identical(other.keyId, keyId) || other.keyId == keyId) &&
            (identical(other.keyType, keyType) || other.keyType == keyType));
  }

  @override
  int get hashCode => Object.hash(runtimeType, keyId, keyType);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CalErrorKind_MissingKeyImplCopyWith<_$CalErrorKind_MissingKeyImpl>
      get copyWith => __$$CalErrorKind_MissingKeyImplCopyWithImpl<
          _$CalErrorKind_MissingKeyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notImplemented,
    required TResult Function(String description, bool internal) badParameter,
    required TResult Function(String keyId, KeyType keyType) missingKey,
    required TResult Function(String description, bool internal) missingValue,
    required TResult Function(String description, bool internal)
        failedOperation,
    required TResult Function(String description, bool internal)
        initializationError,
    required TResult Function(String field0) unsupportedAlgorithm,
    required TResult Function() other,
  }) {
    return missingKey(keyId, keyType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notImplemented,
    TResult? Function(String description, bool internal)? badParameter,
    TResult? Function(String keyId, KeyType keyType)? missingKey,
    TResult? Function(String description, bool internal)? missingValue,
    TResult? Function(String description, bool internal)? failedOperation,
    TResult? Function(String description, bool internal)? initializationError,
    TResult? Function(String field0)? unsupportedAlgorithm,
    TResult? Function()? other,
  }) {
    return missingKey?.call(keyId, keyType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notImplemented,
    TResult Function(String description, bool internal)? badParameter,
    TResult Function(String keyId, KeyType keyType)? missingKey,
    TResult Function(String description, bool internal)? missingValue,
    TResult Function(String description, bool internal)? failedOperation,
    TResult Function(String description, bool internal)? initializationError,
    TResult Function(String field0)? unsupportedAlgorithm,
    TResult Function()? other,
    required TResult orElse(),
  }) {
    if (missingKey != null) {
      return missingKey(keyId, keyType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalErrorKind_NotImplemented value) notImplemented,
    required TResult Function(CalErrorKind_BadParameter value) badParameter,
    required TResult Function(CalErrorKind_MissingKey value) missingKey,
    required TResult Function(CalErrorKind_MissingValue value) missingValue,
    required TResult Function(CalErrorKind_FailedOperation value)
        failedOperation,
    required TResult Function(CalErrorKind_InitializationError value)
        initializationError,
    required TResult Function(CalErrorKind_UnsupportedAlgorithm value)
        unsupportedAlgorithm,
    required TResult Function(CalErrorKind_Other value) other,
  }) {
    return missingKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult? Function(CalErrorKind_BadParameter value)? badParameter,
    TResult? Function(CalErrorKind_MissingKey value)? missingKey,
    TResult? Function(CalErrorKind_MissingValue value)? missingValue,
    TResult? Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult? Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult? Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult? Function(CalErrorKind_Other value)? other,
  }) {
    return missingKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult Function(CalErrorKind_BadParameter value)? badParameter,
    TResult Function(CalErrorKind_MissingKey value)? missingKey,
    TResult Function(CalErrorKind_MissingValue value)? missingValue,
    TResult Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult Function(CalErrorKind_Other value)? other,
    required TResult orElse(),
  }) {
    if (missingKey != null) {
      return missingKey(this);
    }
    return orElse();
  }
}

abstract class CalErrorKind_MissingKey extends CalErrorKind {
  const factory CalErrorKind_MissingKey(
      {required final String keyId,
      required final KeyType keyType}) = _$CalErrorKind_MissingKeyImpl;
  const CalErrorKind_MissingKey._() : super._();

  String get keyId;
  KeyType get keyType;

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CalErrorKind_MissingKeyImplCopyWith<_$CalErrorKind_MissingKeyImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CalErrorKind_MissingValueImplCopyWith<$Res> {
  factory _$$CalErrorKind_MissingValueImplCopyWith(
          _$CalErrorKind_MissingValueImpl value,
          $Res Function(_$CalErrorKind_MissingValueImpl) then) =
      __$$CalErrorKind_MissingValueImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String description, bool internal});
}

/// @nodoc
class __$$CalErrorKind_MissingValueImplCopyWithImpl<$Res>
    extends _$CalErrorKindCopyWithImpl<$Res, _$CalErrorKind_MissingValueImpl>
    implements _$$CalErrorKind_MissingValueImplCopyWith<$Res> {
  __$$CalErrorKind_MissingValueImplCopyWithImpl(
      _$CalErrorKind_MissingValueImpl _value,
      $Res Function(_$CalErrorKind_MissingValueImpl) _then)
      : super(_value, _then);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
    Object? internal = null,
  }) {
    return _then(_$CalErrorKind_MissingValueImpl(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      internal: null == internal
          ? _value.internal
          : internal // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$CalErrorKind_MissingValueImpl extends CalErrorKind_MissingValue {
  const _$CalErrorKind_MissingValueImpl(
      {required this.description, required this.internal})
      : super._();

  @override
  final String description;

  /// `true` if caused within this library. `false` if caused by another library.
  @override
  final bool internal;

  @override
  String toString() {
    return 'CalErrorKind.missingValue(description: $description, internal: $internal)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalErrorKind_MissingValueImpl &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.internal, internal) ||
                other.internal == internal));
  }

  @override
  int get hashCode => Object.hash(runtimeType, description, internal);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CalErrorKind_MissingValueImplCopyWith<_$CalErrorKind_MissingValueImpl>
      get copyWith => __$$CalErrorKind_MissingValueImplCopyWithImpl<
          _$CalErrorKind_MissingValueImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notImplemented,
    required TResult Function(String description, bool internal) badParameter,
    required TResult Function(String keyId, KeyType keyType) missingKey,
    required TResult Function(String description, bool internal) missingValue,
    required TResult Function(String description, bool internal)
        failedOperation,
    required TResult Function(String description, bool internal)
        initializationError,
    required TResult Function(String field0) unsupportedAlgorithm,
    required TResult Function() other,
  }) {
    return missingValue(description, internal);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notImplemented,
    TResult? Function(String description, bool internal)? badParameter,
    TResult? Function(String keyId, KeyType keyType)? missingKey,
    TResult? Function(String description, bool internal)? missingValue,
    TResult? Function(String description, bool internal)? failedOperation,
    TResult? Function(String description, bool internal)? initializationError,
    TResult? Function(String field0)? unsupportedAlgorithm,
    TResult? Function()? other,
  }) {
    return missingValue?.call(description, internal);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notImplemented,
    TResult Function(String description, bool internal)? badParameter,
    TResult Function(String keyId, KeyType keyType)? missingKey,
    TResult Function(String description, bool internal)? missingValue,
    TResult Function(String description, bool internal)? failedOperation,
    TResult Function(String description, bool internal)? initializationError,
    TResult Function(String field0)? unsupportedAlgorithm,
    TResult Function()? other,
    required TResult orElse(),
  }) {
    if (missingValue != null) {
      return missingValue(description, internal);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalErrorKind_NotImplemented value) notImplemented,
    required TResult Function(CalErrorKind_BadParameter value) badParameter,
    required TResult Function(CalErrorKind_MissingKey value) missingKey,
    required TResult Function(CalErrorKind_MissingValue value) missingValue,
    required TResult Function(CalErrorKind_FailedOperation value)
        failedOperation,
    required TResult Function(CalErrorKind_InitializationError value)
        initializationError,
    required TResult Function(CalErrorKind_UnsupportedAlgorithm value)
        unsupportedAlgorithm,
    required TResult Function(CalErrorKind_Other value) other,
  }) {
    return missingValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult? Function(CalErrorKind_BadParameter value)? badParameter,
    TResult? Function(CalErrorKind_MissingKey value)? missingKey,
    TResult? Function(CalErrorKind_MissingValue value)? missingValue,
    TResult? Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult? Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult? Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult? Function(CalErrorKind_Other value)? other,
  }) {
    return missingValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult Function(CalErrorKind_BadParameter value)? badParameter,
    TResult Function(CalErrorKind_MissingKey value)? missingKey,
    TResult Function(CalErrorKind_MissingValue value)? missingValue,
    TResult Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult Function(CalErrorKind_Other value)? other,
    required TResult orElse(),
  }) {
    if (missingValue != null) {
      return missingValue(this);
    }
    return orElse();
  }
}

abstract class CalErrorKind_MissingValue extends CalErrorKind {
  const factory CalErrorKind_MissingValue(
      {required final String description,
      required final bool internal}) = _$CalErrorKind_MissingValueImpl;
  const CalErrorKind_MissingValue._() : super._();

  String get description;

  /// `true` if caused within this library. `false` if caused by another library.
  bool get internal;

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CalErrorKind_MissingValueImplCopyWith<_$CalErrorKind_MissingValueImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CalErrorKind_FailedOperationImplCopyWith<$Res> {
  factory _$$CalErrorKind_FailedOperationImplCopyWith(
          _$CalErrorKind_FailedOperationImpl value,
          $Res Function(_$CalErrorKind_FailedOperationImpl) then) =
      __$$CalErrorKind_FailedOperationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String description, bool internal});
}

/// @nodoc
class __$$CalErrorKind_FailedOperationImplCopyWithImpl<$Res>
    extends _$CalErrorKindCopyWithImpl<$Res, _$CalErrorKind_FailedOperationImpl>
    implements _$$CalErrorKind_FailedOperationImplCopyWith<$Res> {
  __$$CalErrorKind_FailedOperationImplCopyWithImpl(
      _$CalErrorKind_FailedOperationImpl _value,
      $Res Function(_$CalErrorKind_FailedOperationImpl) _then)
      : super(_value, _then);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
    Object? internal = null,
  }) {
    return _then(_$CalErrorKind_FailedOperationImpl(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      internal: null == internal
          ? _value.internal
          : internal // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$CalErrorKind_FailedOperationImpl extends CalErrorKind_FailedOperation {
  const _$CalErrorKind_FailedOperationImpl(
      {required this.description, required this.internal})
      : super._();

  @override
  final String description;

  /// `true` if caused within this library. `false` if caused by another library.
  @override
  final bool internal;

  @override
  String toString() {
    return 'CalErrorKind.failedOperation(description: $description, internal: $internal)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalErrorKind_FailedOperationImpl &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.internal, internal) ||
                other.internal == internal));
  }

  @override
  int get hashCode => Object.hash(runtimeType, description, internal);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CalErrorKind_FailedOperationImplCopyWith<
          _$CalErrorKind_FailedOperationImpl>
      get copyWith => __$$CalErrorKind_FailedOperationImplCopyWithImpl<
          _$CalErrorKind_FailedOperationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notImplemented,
    required TResult Function(String description, bool internal) badParameter,
    required TResult Function(String keyId, KeyType keyType) missingKey,
    required TResult Function(String description, bool internal) missingValue,
    required TResult Function(String description, bool internal)
        failedOperation,
    required TResult Function(String description, bool internal)
        initializationError,
    required TResult Function(String field0) unsupportedAlgorithm,
    required TResult Function() other,
  }) {
    return failedOperation(description, internal);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notImplemented,
    TResult? Function(String description, bool internal)? badParameter,
    TResult? Function(String keyId, KeyType keyType)? missingKey,
    TResult? Function(String description, bool internal)? missingValue,
    TResult? Function(String description, bool internal)? failedOperation,
    TResult? Function(String description, bool internal)? initializationError,
    TResult? Function(String field0)? unsupportedAlgorithm,
    TResult? Function()? other,
  }) {
    return failedOperation?.call(description, internal);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notImplemented,
    TResult Function(String description, bool internal)? badParameter,
    TResult Function(String keyId, KeyType keyType)? missingKey,
    TResult Function(String description, bool internal)? missingValue,
    TResult Function(String description, bool internal)? failedOperation,
    TResult Function(String description, bool internal)? initializationError,
    TResult Function(String field0)? unsupportedAlgorithm,
    TResult Function()? other,
    required TResult orElse(),
  }) {
    if (failedOperation != null) {
      return failedOperation(description, internal);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalErrorKind_NotImplemented value) notImplemented,
    required TResult Function(CalErrorKind_BadParameter value) badParameter,
    required TResult Function(CalErrorKind_MissingKey value) missingKey,
    required TResult Function(CalErrorKind_MissingValue value) missingValue,
    required TResult Function(CalErrorKind_FailedOperation value)
        failedOperation,
    required TResult Function(CalErrorKind_InitializationError value)
        initializationError,
    required TResult Function(CalErrorKind_UnsupportedAlgorithm value)
        unsupportedAlgorithm,
    required TResult Function(CalErrorKind_Other value) other,
  }) {
    return failedOperation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult? Function(CalErrorKind_BadParameter value)? badParameter,
    TResult? Function(CalErrorKind_MissingKey value)? missingKey,
    TResult? Function(CalErrorKind_MissingValue value)? missingValue,
    TResult? Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult? Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult? Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult? Function(CalErrorKind_Other value)? other,
  }) {
    return failedOperation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult Function(CalErrorKind_BadParameter value)? badParameter,
    TResult Function(CalErrorKind_MissingKey value)? missingKey,
    TResult Function(CalErrorKind_MissingValue value)? missingValue,
    TResult Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult Function(CalErrorKind_Other value)? other,
    required TResult orElse(),
  }) {
    if (failedOperation != null) {
      return failedOperation(this);
    }
    return orElse();
  }
}

abstract class CalErrorKind_FailedOperation extends CalErrorKind {
  const factory CalErrorKind_FailedOperation(
      {required final String description,
      required final bool internal}) = _$CalErrorKind_FailedOperationImpl;
  const CalErrorKind_FailedOperation._() : super._();

  String get description;

  /// `true` if caused within this library. `false` if caused by another library.
  bool get internal;

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CalErrorKind_FailedOperationImplCopyWith<
          _$CalErrorKind_FailedOperationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CalErrorKind_InitializationErrorImplCopyWith<$Res> {
  factory _$$CalErrorKind_InitializationErrorImplCopyWith(
          _$CalErrorKind_InitializationErrorImpl value,
          $Res Function(_$CalErrorKind_InitializationErrorImpl) then) =
      __$$CalErrorKind_InitializationErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String description, bool internal});
}

/// @nodoc
class __$$CalErrorKind_InitializationErrorImplCopyWithImpl<$Res>
    extends _$CalErrorKindCopyWithImpl<$Res,
        _$CalErrorKind_InitializationErrorImpl>
    implements _$$CalErrorKind_InitializationErrorImplCopyWith<$Res> {
  __$$CalErrorKind_InitializationErrorImplCopyWithImpl(
      _$CalErrorKind_InitializationErrorImpl _value,
      $Res Function(_$CalErrorKind_InitializationErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
    Object? internal = null,
  }) {
    return _then(_$CalErrorKind_InitializationErrorImpl(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      internal: null == internal
          ? _value.internal
          : internal // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$CalErrorKind_InitializationErrorImpl
    extends CalErrorKind_InitializationError {
  const _$CalErrorKind_InitializationErrorImpl(
      {required this.description, required this.internal})
      : super._();

  @override
  final String description;

  /// `true` if caused within this library. `false` if caused by another library.
  @override
  final bool internal;

  @override
  String toString() {
    return 'CalErrorKind.initializationError(description: $description, internal: $internal)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalErrorKind_InitializationErrorImpl &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.internal, internal) ||
                other.internal == internal));
  }

  @override
  int get hashCode => Object.hash(runtimeType, description, internal);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CalErrorKind_InitializationErrorImplCopyWith<
          _$CalErrorKind_InitializationErrorImpl>
      get copyWith => __$$CalErrorKind_InitializationErrorImplCopyWithImpl<
          _$CalErrorKind_InitializationErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notImplemented,
    required TResult Function(String description, bool internal) badParameter,
    required TResult Function(String keyId, KeyType keyType) missingKey,
    required TResult Function(String description, bool internal) missingValue,
    required TResult Function(String description, bool internal)
        failedOperation,
    required TResult Function(String description, bool internal)
        initializationError,
    required TResult Function(String field0) unsupportedAlgorithm,
    required TResult Function() other,
  }) {
    return initializationError(description, internal);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notImplemented,
    TResult? Function(String description, bool internal)? badParameter,
    TResult? Function(String keyId, KeyType keyType)? missingKey,
    TResult? Function(String description, bool internal)? missingValue,
    TResult? Function(String description, bool internal)? failedOperation,
    TResult? Function(String description, bool internal)? initializationError,
    TResult? Function(String field0)? unsupportedAlgorithm,
    TResult? Function()? other,
  }) {
    return initializationError?.call(description, internal);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notImplemented,
    TResult Function(String description, bool internal)? badParameter,
    TResult Function(String keyId, KeyType keyType)? missingKey,
    TResult Function(String description, bool internal)? missingValue,
    TResult Function(String description, bool internal)? failedOperation,
    TResult Function(String description, bool internal)? initializationError,
    TResult Function(String field0)? unsupportedAlgorithm,
    TResult Function()? other,
    required TResult orElse(),
  }) {
    if (initializationError != null) {
      return initializationError(description, internal);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalErrorKind_NotImplemented value) notImplemented,
    required TResult Function(CalErrorKind_BadParameter value) badParameter,
    required TResult Function(CalErrorKind_MissingKey value) missingKey,
    required TResult Function(CalErrorKind_MissingValue value) missingValue,
    required TResult Function(CalErrorKind_FailedOperation value)
        failedOperation,
    required TResult Function(CalErrorKind_InitializationError value)
        initializationError,
    required TResult Function(CalErrorKind_UnsupportedAlgorithm value)
        unsupportedAlgorithm,
    required TResult Function(CalErrorKind_Other value) other,
  }) {
    return initializationError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult? Function(CalErrorKind_BadParameter value)? badParameter,
    TResult? Function(CalErrorKind_MissingKey value)? missingKey,
    TResult? Function(CalErrorKind_MissingValue value)? missingValue,
    TResult? Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult? Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult? Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult? Function(CalErrorKind_Other value)? other,
  }) {
    return initializationError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult Function(CalErrorKind_BadParameter value)? badParameter,
    TResult Function(CalErrorKind_MissingKey value)? missingKey,
    TResult Function(CalErrorKind_MissingValue value)? missingValue,
    TResult Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult Function(CalErrorKind_Other value)? other,
    required TResult orElse(),
  }) {
    if (initializationError != null) {
      return initializationError(this);
    }
    return orElse();
  }
}

abstract class CalErrorKind_InitializationError extends CalErrorKind {
  const factory CalErrorKind_InitializationError(
      {required final String description,
      required final bool internal}) = _$CalErrorKind_InitializationErrorImpl;
  const CalErrorKind_InitializationError._() : super._();

  String get description;

  /// `true` if caused within this library. `false` if caused by another library.
  bool get internal;

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CalErrorKind_InitializationErrorImplCopyWith<
          _$CalErrorKind_InitializationErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CalErrorKind_UnsupportedAlgorithmImplCopyWith<$Res> {
  factory _$$CalErrorKind_UnsupportedAlgorithmImplCopyWith(
          _$CalErrorKind_UnsupportedAlgorithmImpl value,
          $Res Function(_$CalErrorKind_UnsupportedAlgorithmImpl) then) =
      __$$CalErrorKind_UnsupportedAlgorithmImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$CalErrorKind_UnsupportedAlgorithmImplCopyWithImpl<$Res>
    extends _$CalErrorKindCopyWithImpl<$Res,
        _$CalErrorKind_UnsupportedAlgorithmImpl>
    implements _$$CalErrorKind_UnsupportedAlgorithmImplCopyWith<$Res> {
  __$$CalErrorKind_UnsupportedAlgorithmImplCopyWithImpl(
      _$CalErrorKind_UnsupportedAlgorithmImpl _value,
      $Res Function(_$CalErrorKind_UnsupportedAlgorithmImpl) _then)
      : super(_value, _then);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$CalErrorKind_UnsupportedAlgorithmImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CalErrorKind_UnsupportedAlgorithmImpl
    extends CalErrorKind_UnsupportedAlgorithm {
  const _$CalErrorKind_UnsupportedAlgorithmImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'CalErrorKind.unsupportedAlgorithm(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalErrorKind_UnsupportedAlgorithmImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CalErrorKind_UnsupportedAlgorithmImplCopyWith<
          _$CalErrorKind_UnsupportedAlgorithmImpl>
      get copyWith => __$$CalErrorKind_UnsupportedAlgorithmImplCopyWithImpl<
          _$CalErrorKind_UnsupportedAlgorithmImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notImplemented,
    required TResult Function(String description, bool internal) badParameter,
    required TResult Function(String keyId, KeyType keyType) missingKey,
    required TResult Function(String description, bool internal) missingValue,
    required TResult Function(String description, bool internal)
        failedOperation,
    required TResult Function(String description, bool internal)
        initializationError,
    required TResult Function(String field0) unsupportedAlgorithm,
    required TResult Function() other,
  }) {
    return unsupportedAlgorithm(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notImplemented,
    TResult? Function(String description, bool internal)? badParameter,
    TResult? Function(String keyId, KeyType keyType)? missingKey,
    TResult? Function(String description, bool internal)? missingValue,
    TResult? Function(String description, bool internal)? failedOperation,
    TResult? Function(String description, bool internal)? initializationError,
    TResult? Function(String field0)? unsupportedAlgorithm,
    TResult? Function()? other,
  }) {
    return unsupportedAlgorithm?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notImplemented,
    TResult Function(String description, bool internal)? badParameter,
    TResult Function(String keyId, KeyType keyType)? missingKey,
    TResult Function(String description, bool internal)? missingValue,
    TResult Function(String description, bool internal)? failedOperation,
    TResult Function(String description, bool internal)? initializationError,
    TResult Function(String field0)? unsupportedAlgorithm,
    TResult Function()? other,
    required TResult orElse(),
  }) {
    if (unsupportedAlgorithm != null) {
      return unsupportedAlgorithm(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalErrorKind_NotImplemented value) notImplemented,
    required TResult Function(CalErrorKind_BadParameter value) badParameter,
    required TResult Function(CalErrorKind_MissingKey value) missingKey,
    required TResult Function(CalErrorKind_MissingValue value) missingValue,
    required TResult Function(CalErrorKind_FailedOperation value)
        failedOperation,
    required TResult Function(CalErrorKind_InitializationError value)
        initializationError,
    required TResult Function(CalErrorKind_UnsupportedAlgorithm value)
        unsupportedAlgorithm,
    required TResult Function(CalErrorKind_Other value) other,
  }) {
    return unsupportedAlgorithm(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult? Function(CalErrorKind_BadParameter value)? badParameter,
    TResult? Function(CalErrorKind_MissingKey value)? missingKey,
    TResult? Function(CalErrorKind_MissingValue value)? missingValue,
    TResult? Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult? Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult? Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult? Function(CalErrorKind_Other value)? other,
  }) {
    return unsupportedAlgorithm?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult Function(CalErrorKind_BadParameter value)? badParameter,
    TResult Function(CalErrorKind_MissingKey value)? missingKey,
    TResult Function(CalErrorKind_MissingValue value)? missingValue,
    TResult Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult Function(CalErrorKind_Other value)? other,
    required TResult orElse(),
  }) {
    if (unsupportedAlgorithm != null) {
      return unsupportedAlgorithm(this);
    }
    return orElse();
  }
}

abstract class CalErrorKind_UnsupportedAlgorithm extends CalErrorKind {
  const factory CalErrorKind_UnsupportedAlgorithm(final String field0) =
      _$CalErrorKind_UnsupportedAlgorithmImpl;
  const CalErrorKind_UnsupportedAlgorithm._() : super._();

  String get field0;

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CalErrorKind_UnsupportedAlgorithmImplCopyWith<
          _$CalErrorKind_UnsupportedAlgorithmImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CalErrorKind_OtherImplCopyWith<$Res> {
  factory _$$CalErrorKind_OtherImplCopyWith(_$CalErrorKind_OtherImpl value,
          $Res Function(_$CalErrorKind_OtherImpl) then) =
      __$$CalErrorKind_OtherImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CalErrorKind_OtherImplCopyWithImpl<$Res>
    extends _$CalErrorKindCopyWithImpl<$Res, _$CalErrorKind_OtherImpl>
    implements _$$CalErrorKind_OtherImplCopyWith<$Res> {
  __$$CalErrorKind_OtherImplCopyWithImpl(_$CalErrorKind_OtherImpl _value,
      $Res Function(_$CalErrorKind_OtherImpl) _then)
      : super(_value, _then);

  /// Create a copy of CalErrorKind
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CalErrorKind_OtherImpl extends CalErrorKind_Other {
  const _$CalErrorKind_OtherImpl() : super._();

  @override
  String toString() {
    return 'CalErrorKind.other()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CalErrorKind_OtherImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notImplemented,
    required TResult Function(String description, bool internal) badParameter,
    required TResult Function(String keyId, KeyType keyType) missingKey,
    required TResult Function(String description, bool internal) missingValue,
    required TResult Function(String description, bool internal)
        failedOperation,
    required TResult Function(String description, bool internal)
        initializationError,
    required TResult Function(String field0) unsupportedAlgorithm,
    required TResult Function() other,
  }) {
    return other();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notImplemented,
    TResult? Function(String description, bool internal)? badParameter,
    TResult? Function(String keyId, KeyType keyType)? missingKey,
    TResult? Function(String description, bool internal)? missingValue,
    TResult? Function(String description, bool internal)? failedOperation,
    TResult? Function(String description, bool internal)? initializationError,
    TResult? Function(String field0)? unsupportedAlgorithm,
    TResult? Function()? other,
  }) {
    return other?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notImplemented,
    TResult Function(String description, bool internal)? badParameter,
    TResult Function(String keyId, KeyType keyType)? missingKey,
    TResult Function(String description, bool internal)? missingValue,
    TResult Function(String description, bool internal)? failedOperation,
    TResult Function(String description, bool internal)? initializationError,
    TResult Function(String field0)? unsupportedAlgorithm,
    TResult Function()? other,
    required TResult orElse(),
  }) {
    if (other != null) {
      return other();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalErrorKind_NotImplemented value) notImplemented,
    required TResult Function(CalErrorKind_BadParameter value) badParameter,
    required TResult Function(CalErrorKind_MissingKey value) missingKey,
    required TResult Function(CalErrorKind_MissingValue value) missingValue,
    required TResult Function(CalErrorKind_FailedOperation value)
        failedOperation,
    required TResult Function(CalErrorKind_InitializationError value)
        initializationError,
    required TResult Function(CalErrorKind_UnsupportedAlgorithm value)
        unsupportedAlgorithm,
    required TResult Function(CalErrorKind_Other value) other,
  }) {
    return other(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult? Function(CalErrorKind_BadParameter value)? badParameter,
    TResult? Function(CalErrorKind_MissingKey value)? missingKey,
    TResult? Function(CalErrorKind_MissingValue value)? missingValue,
    TResult? Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult? Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult? Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult? Function(CalErrorKind_Other value)? other,
  }) {
    return other?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalErrorKind_NotImplemented value)? notImplemented,
    TResult Function(CalErrorKind_BadParameter value)? badParameter,
    TResult Function(CalErrorKind_MissingKey value)? missingKey,
    TResult Function(CalErrorKind_MissingValue value)? missingValue,
    TResult Function(CalErrorKind_FailedOperation value)? failedOperation,
    TResult Function(CalErrorKind_InitializationError value)?
        initializationError,
    TResult Function(CalErrorKind_UnsupportedAlgorithm value)?
        unsupportedAlgorithm,
    TResult Function(CalErrorKind_Other value)? other,
    required TResult orElse(),
  }) {
    if (other != null) {
      return other(this);
    }
    return orElse();
  }
}

abstract class CalErrorKind_Other extends CalErrorKind {
  const factory CalErrorKind_Other() = _$CalErrorKind_OtherImpl;
  const CalErrorKind_Other._() : super._();
}
