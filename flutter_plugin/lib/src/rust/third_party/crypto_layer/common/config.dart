// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../lib.dart';
import '../common.dart';
import 'crypto/algorithms/encryption.dart';
import 'crypto/algorithms/hashes.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'config.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `cmp`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `partial_cmp`

@freezed
sealed class AdditionalConfig with _$AdditionalConfig {
  const AdditionalConfig._();

  const factory AdditionalConfig.kvStoreConfig({
    required ArcFnStringDynFutureOptionVecU8 getFn,
    required ArcFnStringVecU8DynFutureBool storeFn,
    required ArcFnStringPinBoxFutureOutput deleteFn,
    required ArcFnDynFutureVecString allKeysFn,
  }) = AdditionalConfig_KVStoreConfig;
  const factory AdditionalConfig.fileStoreConfig({
    required String dbPath,
    required String securePath,
    required String pass,
  }) = AdditionalConfig_FileStoreConfig;
  const factory AdditionalConfig.storageConfigHmac(
    KeyHandle field0,
  ) = AdditionalConfig_StorageConfigHMAC;
  const factory AdditionalConfig.storageConfigDsa(
    KeyPairHandle field0,
  ) = AdditionalConfig_StorageConfigDSA;
  const factory AdditionalConfig.storageConfigPass(
    String field0,
  ) = AdditionalConfig_StorageConfigPass;
}

/// flutter_rust_bridge:non_opaque
class KeyPairSpec {
  final AsymmetricKeySpec asymSpec;
  final Cipher? cipher;
  final CryptoHash signingHash;
  final bool ephemeral;

  const KeyPairSpec({
    required this.asymSpec,
    this.cipher,
    required this.signingHash,
    required this.ephemeral,
  });

  static Future<KeyPairSpec> default_() =>
      RustLib.instance.api.cryptoLayerCommonConfigKeyPairSpecDefault();

  @override
  int get hashCode =>
      asymSpec.hashCode ^
      cipher.hashCode ^
      signingHash.hashCode ^
      ephemeral.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyPairSpec &&
          runtimeType == other.runtimeType &&
          asymSpec == other.asymSpec &&
          cipher == other.cipher &&
          signingHash == other.signingHash &&
          ephemeral == other.ephemeral;
}

/// flutter_rust_bridge:non_opaque
class KeySpec {
  final Cipher cipher;
  final CryptoHash signingHash;
  final bool ephemeral;

  const KeySpec({
    required this.cipher,
    required this.signingHash,
    required this.ephemeral,
  });

  static Future<KeySpec> default_() =>
      RustLib.instance.api.cryptoLayerCommonConfigKeySpecDefault();

  @override
  int get hashCode =>
      cipher.hashCode ^ signingHash.hashCode ^ ephemeral.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeySpec &&
          runtimeType == other.runtimeType &&
          cipher == other.cipher &&
          signingHash == other.signingHash &&
          ephemeral == other.ephemeral;
}

/// flutter_rust_bridge:non_opaque
class ProviderConfig {
  final SecurityLevel maxSecurityLevel;
  final SecurityLevel minSecurityLevel;
  final Set<Cipher> supportedCiphers;
  final Set<CryptoHash> supportedHashes;
  final Set<AsymmetricKeySpec> supportedAsymSpec;

  const ProviderConfig({
    required this.maxSecurityLevel,
    required this.minSecurityLevel,
    required this.supportedCiphers,
    required this.supportedHashes,
    required this.supportedAsymSpec,
  });

  @override
  int get hashCode =>
      maxSecurityLevel.hashCode ^
      minSecurityLevel.hashCode ^
      supportedCiphers.hashCode ^
      supportedHashes.hashCode ^
      supportedAsymSpec.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProviderConfig &&
          runtimeType == other.runtimeType &&
          maxSecurityLevel == other.maxSecurityLevel &&
          minSecurityLevel == other.minSecurityLevel &&
          supportedCiphers == other.supportedCiphers &&
          supportedHashes == other.supportedHashes &&
          supportedAsymSpec == other.supportedAsymSpec;
}

/// flutter_rust_bridge:non_opaque
class ProviderImplConfig {
  final List<AdditionalConfig> additionalConfig;
  final bool ephemeralKeys;

  const ProviderImplConfig({
    required this.additionalConfig,
    required this.ephemeralKeys,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new `ProviderImplConfig` instance.
  static Future<ProviderImplConfig> newInstance(
          {required ArcFnStringDynFutureOptionVecU8 getFn,
          required ArcFnStringVecU8DynFutureBool storeFn,
          required ArcFnStringPinBoxFutureOutput deleteFn,
          required ArcFnDynFutureVecString allKeysFn,
          required List<AdditionalConfig> additionalConfig,
          required bool ephemeralKeys}) =>
      RustLib.instance.api.cryptoLayerCommonConfigProviderImplConfigNew(
          getFn: getFn,
          storeFn: storeFn,
          deleteFn: deleteFn,
          allKeysFn: allKeysFn,
          additionalConfig: additionalConfig,
          ephemeralKeys: ephemeralKeys);

  @override
  int get hashCode => additionalConfig.hashCode ^ ephemeralKeys.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProviderImplConfig &&
          runtimeType == other.runtimeType &&
          additionalConfig == other.additionalConfig &&
          ephemeralKeys == other.ephemeralKeys;
}

/// Enum describing the security level of a provider.
///
/// * [SecurityLevel::Hardware]: Provider is hardware backed (tpm, other security chips, StrongBox KeyStore).
/// * [SecurityLevel::Software]: Provder uses the systems software keystore.
/// * [SecurityLevel::Network]: Provider uses a network key store (Hashicorp).
/// * [SecurityLevel::Unsafe]: Provder uses software fallback.
enum SecurityLevel {
  /// Highest security level
  hardware,
  software,
  network,
  unsafe,
  ;
}

@freezed
sealed class Spec with _$Spec {
  const Spec._();

  const factory Spec.keySpec(
    KeySpec field0,
  ) = Spec_KeySpec;
  const factory Spec.keyPairSpec(
    KeyPairSpec field0,
  ) = Spec_KeyPairSpec;
}
