// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import 'crypto/algorithms.dart';
import 'crypto/algorithms/encryption.dart';
import 'crypto/algorithms/hashes.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `get_additional_config_as`
// These types are ignored because they are not used by any `pub` functions: `SerializableSpec`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `cmp`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `partial_cmp`
// These functions are ignored (category: IgnoreBecauseNotAllowedOwner): `as_any`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn AdditionalConfig >>>
abstract class ArcAdditionalConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn Any + Send + Sync >>>
abstract class ArcAny implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn Fn () -> DynFuture < Vec < String > > + Send + Sync >>>
abstract class ArcFnDynFutureVecString implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn Fn (String) -> DynFuture < Option < Vec < u8 > > > + Send + Sync >>>
abstract class ArcFnStringDynFutureOptionVecU8 implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn Fn (String) -> Pin < Box < dyn Future < Output = () > + Send > > + Send + Sync >>>
abstract class ArcFnStringPinBoxFutureOutput implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn Fn (String , Vec < u8 >) -> DynFuture < bool > + Send + Sync >>>
abstract class ArcFnStringVecU8DynFutureBool implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConfigHandle>>
abstract class ConfigHandle implements RustOpaqueInterface {
  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ConfigHandle> newInstance(
          {required ArcAdditionalConfig implementation}) =>
      RustLib.instance.api.cryptoLayerCommonConfigConfigHandleNew(
          implementation: implementation);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProviderImplConfig>>
abstract class ProviderImplConfig implements RustOpaqueInterface {
  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new `ProviderImplConfig` instance.
  static Future<ProviderImplConfig> newInstance(
          {ArcAny? javaVm,
          required ArcFnStringDynFutureOptionVecU8 getFn,
          required ArcFnStringVecU8DynFutureBool storeFn,
          required ArcFnStringPinBoxFutureOutput deleteFn,
          required ArcFnDynFutureVecString allKeysFn,
          ConfigHandle? additionalConfig}) =>
      RustLib.instance.api.cryptoLayerCommonConfigProviderImplConfigNew(
          javaVm: javaVm,
          getFn: getFn,
          storeFn: storeFn,
          deleteFn: deleteFn,
          allKeysFn: allKeysFn,
          additionalConfig: additionalConfig);

  /// Creates a new stubbed `ProviderImplConfig` instance for testing or default purposes.
  static Future<ProviderImplConfig> newStub(
          {ArcAny? javaVm,
          required ArcFnStringDynFutureOptionVecU8 getFn,
          required ArcFnStringVecU8DynFutureBool storeFn,
          required ArcFnStringPinBoxFutureOutput deleteFn,
          required ArcFnDynFutureVecString allKeysFn,
          ConfigHandle? additionalConfig}) =>
      RustLib.instance.api.cryptoLayerCommonConfigProviderImplConfigNewStub(
          javaVm: javaVm,
          getFn: getFn,
          storeFn: storeFn,
          deleteFn: deleteFn,
          allKeysFn: allKeysFn,
          additionalConfig: additionalConfig);
}

abstract class AdditionalConfig {
  /// Provides a reference to `self` as `&dyn Any` to enable downcasting to concrete types.
  Future<void> asAny();
}

/// flutter_rust_bridge:non_opaque
class KeyPairSpec {
  final AsymmetricKeySpec asymSpec;
  final Cipher? cipher;
  final CryptoHash signingHash;

  const KeyPairSpec({
    required this.asymSpec,
    this.cipher,
    required this.signingHash,
  });

  static Future<KeyPairSpec> default_() =>
      RustLib.instance.api.cryptoLayerCommonConfigKeyPairSpecDefault();

  @override
  int get hashCode =>
      asymSpec.hashCode ^ cipher.hashCode ^ signingHash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyPairSpec &&
          runtimeType == other.runtimeType &&
          asymSpec == other.asymSpec &&
          cipher == other.cipher &&
          signingHash == other.signingHash;
}

/// flutter_rust_bridge:non_opaque
class KeySpec {
  final Cipher cipher;
  final CryptoHash signingHash;

  const KeySpec({
    required this.cipher,
    required this.signingHash,
  });

  static Future<KeySpec> default_() =>
      RustLib.instance.api.cryptoLayerCommonConfigKeySpecDefault();

  @override
  int get hashCode => cipher.hashCode ^ signingHash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeySpec &&
          runtimeType == other.runtimeType &&
          cipher == other.cipher &&
          signingHash == other.signingHash;
}

/// flutter_rust_bridge:non_opaque
class ProviderConfig {
  final SecurityLevel maxSecurityLevel;
  final SecurityLevel minSecurityLevel;
  final Set<Cipher> supportedCiphers;
  final Set<CryptoHash> supportedHashes;
  final Set<AsymmetricKeySpec> supportedAsymSpec;

  const ProviderConfig({
    required this.maxSecurityLevel,
    required this.minSecurityLevel,
    required this.supportedCiphers,
    required this.supportedHashes,
    required this.supportedAsymSpec,
  });

  @override
  int get hashCode =>
      maxSecurityLevel.hashCode ^
      minSecurityLevel.hashCode ^
      supportedCiphers.hashCode ^
      supportedHashes.hashCode ^
      supportedAsymSpec.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProviderConfig &&
          runtimeType == other.runtimeType &&
          maxSecurityLevel == other.maxSecurityLevel &&
          minSecurityLevel == other.minSecurityLevel &&
          supportedCiphers == other.supportedCiphers &&
          supportedHashes == other.supportedHashes &&
          supportedAsymSpec == other.supportedAsymSpec;
}

/// Enum describing the security level of a provider.
///
/// * [SecurityLevel::Hardware]: Provider is hardware backed (tpm, other security chips, StrongBox KeyStore).
/// * [SecurityLevel::Software]: Provder uses the systems software keystore.
/// * [SecurityLevel::Network]: Provider uses a network key store (Hashicorp).
/// * [SecurityLevel::Unsafe]: Provder uses software fallback.
enum SecurityLevel {
  /// Highest security level
  hardware,
  software,
  network,
  unsafe,
  ;
}
